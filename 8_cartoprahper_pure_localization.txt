1. carto_mapper mapper.launch 실행

2. 터미널에서 rosservice call /finish_trajectory 0 입력
-맵 기록을 중단한다.

3. 터미널에서 rosservice call /write_state /home/nvidia/원하는이름.bag.pbstream

4. cartographer의 x2.lua를 복사하고 아래 내용을 추가한다.
test.lua
TRAJECTORY_BUILDER.pure_localization = true
POSE_GRAPH.optimize_every_n_nodes = 20
 
5. carto_mapper의 mapper.launch를 복사하고 아래 내용을 추가한다.
test_local.launch
-configuration_basename test.lua (lua파일을 4번에서 만든 이름으로 지정한다.)
-load_state_filename $(arg load_state_filename)

6. 터미널에서 carto_mapper test_local.launch load_state_filename:=${HOME}/저장된것.bag.pbstream




// 내부만 검은색 맵 만들기 //
#include <ros/ros.h>
#include <nav_msgs/MapMetaData.h>
#include <nav_msgs/OccupancyGrid.h>
#include "std_msgs/Header.h"
#include "nav_msgs/MapMetaData.h"
#include <vector>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <chrono>
#include "tf/transform_listener.h"
#include <cstdio>
#include "project_ros_cpp/nano_control.h"

#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <opencv2/imgproc/imgproc.hpp>

#define _USE_MATH_DEFINES

int add_padding(cv::Mat resizing_mat)
{
	if ( resizing_mat.rows >= resizing_mat.cols )
	{
		return int(resizing_mat.rows)+20;
	}
	else
	{
		return int(resizing_mat.cols)+20;
	}
}

void mapCallback(const nav_msgs::OccupancyGrid::ConstPtr& msg){

	std::string start = std::string("/map"); 
	std::string move = std::string("/base_footprint");
	double my_RAD2DEG = 180.0/M_PI;

	tf::TransformListener tfl;
	tfl.waitForTransform(start, move, ros::Time(), ros::Duration(3.0));

	tf::StampedTransform my_test_transform;
	tfl.lookupTransform(start, move, ros::Time(), my_test_transform);

	double yaw, pitch, roll;
	my_test_transform.getBasis().getRPY(roll, pitch, yaw);
	tf::Quaternion q = my_test_transform.getRotation();
	tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

	std::cout<<"Map 으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
	std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
	std::cout<<"축 회전 각 [degree] (roll, pitch, yaw)"<<std::endl;
	std::cout<<"	("<<roll*my_RAD2DEG<<", "<<pitch*my_RAD2DEG<<", "<<yaw*my_RAD2DEG<<")"<< std::endl;

	/*
	std::cout << atan2(-10,20)*180.0/M_PI << std::endl; // -26
	std::cout << atan2(-10,-20)*180.0/M_PI << std::endl; // -154
	std::cout << atan2(10,-20)*180.0/M_PI << std::endl; // 154
	std::cout << atan2(10,20)*180.0/M_PI << std::endl; // 26
	*/

	double middle_yaw;
	if ( Coordinate_3D.getY() < 0  )
	{
		middle_yaw = 180.0 + (atan2(Coordinate_3D.getY()*100,Coordinate_3D.getX()*100)*180.0/M_PI ) ;
	}
	else
	{
		middle_yaw = -180.0 + (atan2(Coordinate_3D.getY()*100,Coordinate_3D.getX()*100)*180.0/M_PI );
	}

	// 계산시 cm단위로 변환하고 연산한다.
	double target_x = 20.0;
	double target_y = 10.0;
	double line_a = sqrt(pow(target_x,2)+pow(target_y,2));
	double line_b = sqrt(pow(Coordinate_3D.getX()*100,2)+pow(Coordinate_3D.getY()*100,2));
	double line_c = sqrt(pow(Coordinate_3D.getX()*100-target_x,2)+pow(Coordinate_3D.getY()*100-target_y,2));

	double finish_yaw_data = (pow(line_a,2)-(pow(line_b,2)+pow(line_c,2)))/(-2*line_b*line_c);
	double finish_yaw = acos( finish_yaw_data )*180.0/M_PI;

	// 직선의 방적식을 구해서, 위에 있으면 시계방향, 아래있으면 반시계 방향
	double where_is_point = target_y - (Coordinate_3D.getY()/Coordinate_3D.getX())*target_x;
	double destination_degree = 0.0;
	if ( where_is_point > 0 )
		destination_degree = middle_yaw - finish_yaw;
	else
		destination_degree = middle_yaw + finish_yaw;

	std::cout << destination_degree << std::endl;
	
	ros::NodeHandle nh;
	ros::Publisher nano_move_pub = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 100);
	project_ros_cpp::nano_control nano_order;
	
	if ( yaw*180.0/M_PI < destination_degree )
	{
		// 좌회전
		std::cout << "좌회전" << std::endl;
		nano_order.move_message = 7;
	}
	else if ( yaw*180.0/M_PI > destination_degree  )
	{
		// 우회전
		std::cout << "우회전" << std::endl;
		nano_order.move_message = 6;
	}
	else if ( yaw*180.0/M_PI > destination_degree-5 && yaw*180.0/M_PI < destination_degree+5 )
	{
		// 회전 정지
		std::cout << "정지" << std::endl;
		nano_order.move_message = 5;
	}

	nano_move_pub.publish(nano_order);
	ros::spin();

	std_msgs::Header header = msg->header;
	nav_msgs::MapMetaData info = msg->info;
	ROS_INFO("Got map %d %d", info.width, info.height);
	//cv::Mat origin(info.width, info.height, CV_8UC1);
	std::vector<signed char> data = msg->data;

	cv::Mat meta_data = cv::Mat(data).reshape(1,info.height);
	cv::Mat meta_resize;
	meta_data.convertTo(meta_resize,CV_8UC1);
	int mat_size = add_padding(meta_resize);
	cv::Mat original(mat_size, mat_size, CV_8UC1, cv::Scalar(0));
	for (int i=0; i<meta_resize.rows; i++)
		for (int j=0; j<meta_resize.cols; j++)
			original.at<unsigned char>(i+10,j+10) = meta_resize.at<unsigned char>(i,j);

	cv::Mat wall_padding_mat(original.size(),original.type(),cv::Scalar(0));
	int pdding_size = 10; // 10이면 벽의 상하좌우로 5px씩, 10cm
	for (int i=0; i<original.rows; i++)
		for (int j=0; j<original.cols; j++)
			if ( int(original.at<unsigned char>(i,j)) > 0 )
				for ( int k=0; k<=pdding_size; k++ )
					for ( int l=0; l<=pdding_size; l++ )
					{
						//std::cout << "here 2" << std::endl;
						if ( (i+k-5)<0 || (i+k-5)>=original.rows || (j+l-5)<0 || (j+l-5)>=original.cols ) {}
						else { wall_padding_mat.at<unsigned char>( (i+k-5), (j+l-5) )=255; }
					}



	cv::Mat canny_temp;
	cv::Canny(wall_padding_mat, canny_temp, 100, 100*2, 3);
	std::vector<std::vector<cv::Point>> contours;
	std::vector<cv::Vec4i> hierarchy;
	cv::findContours(canny_temp, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);

	/*
	cv::Mat show_contour;
	cv::cvtColor(wall_padding_mat, show_contour, cv::COLOR_GRAY2BGR);
	for ( int i=0; i<int(contours.size()); i++)
	{
		cv::drawContours(show_contour, contours, i, cv::Scalar(255,0,0),2,8,hierarchy,0,cv::Point());
	}
	std::cout << contours[0] << std::endl;
	std::cout << contours[0][0] << std::endl;
	std::cout << contours[0][0].x << std::endl;
	std::cout << contours[0][0].y << std::endl;
	std::cout << int(contours.size()) << std::endl;
	std::cout << int(contours[0].size()) << std::endl;
	cv::imshow("show_contour", show_contour);
	*/

	cv::Mat back_ground_white(wall_padding_mat.size(), wall_padding_mat.type(), cv::Scalar(0,0,0));
	cv::fillPoly(back_ground_white, contours, cv::Scalar(255,255,255));

	for (int i=0; i<back_ground_white.rows; i++)
		for (int j=0; j<back_ground_white.cols; j++)
			if ( back_ground_white.at<unsigned char>(i,j) == 0 )
				back_ground_white.at<unsigned char>(i,j) = 255;
			else
				back_ground_white.at<unsigned char>(i,j) = 0;

	wall_padding_mat = wall_padding_mat + back_ground_white;

	for ( int i=0; i<int(contours.size()); i++)
	{
		cv::drawContours(wall_padding_mat, contours, i, cv::Scalar(255,255,255),2,8,hierarchy,0,cv::Point());
	}

	cv::imshow("meta_data", meta_data);
	cv::imshow("original", original);
	cv::imshow("back_ground_white", back_ground_white);
	cv::imshow("wall_padding_mat", wall_padding_mat);
	cv::waitKey(100);
	//cv::destroyWindow("image");

}

int main(int argc, char **argv){
	ros::init(argc, argv, "map_reader");
	ros::NodeHandle n;
	ros::Subscriber map_sub = n.subscribe("map",2000,mapCallback);
	ros::spin();

	return 0;

}








// 회전 + 직진 //
#include <ros/ros.h>
#include <iostream>
#include "tf/transform_listener.h"
#include "project_ros_cpp/nano_control.h"
#include <unistd.h>


double target_x = 0.0; // 목표위치 x
double target_y = 50.0; // 목표위치 y

void find_yaw()
{

	ros::NodeHandle nh;
	ros::Publisher nano_move_pub = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);

	tf::TransformListener tfl;
	tf::StampedTransform my_test_transform;

	std::string start = std::string("/map"); 
	std::string move = std::string("/base_footprint");

	while (ros::ok())
	{		
		tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
		tfl.lookupTransform(start, move, ros::Time(), my_test_transform);

		double yaw, pitch, roll;
		my_test_transform.getBasis().getRPY(roll, pitch, yaw);
		tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

		/*
		std::cout << atan2(-10,20)*180.0/M_PI << std::endl; // -26
		std::cout << atan2(-10,-20)*180.0/M_PI << std::endl; // -154
		std::cout << atan2(10,-20)*180.0/M_PI << std::endl; // 154
		std::cout << atan2(10,20)*180.0/M_PI << std::endl; // 26
		*/

		double middle_yaw;
		if ( Coordinate_3D.getY() < 0  )
		{
			middle_yaw = 180.0 + (atan2(Coordinate_3D.getY()*100,Coordinate_3D.getX()*100)*180.0/M_PI ) ;
		}
		else
		{
			middle_yaw = -180.0 + (atan2(Coordinate_3D.getY()*100,Coordinate_3D.getX()*100)*180.0/M_PI );
		}

		// (0,0) , 현재위치, 목표위치 //
		// 제 2 코사인 법칙 //
		double line_a = sqrt(pow(target_x,2)+pow(target_y,2));
		double line_b = sqrt(pow(Coordinate_3D.getX()*100,2)+pow(Coordinate_3D.getY()*100,2));
		double line_c = sqrt(pow(Coordinate_3D.getX()*100-target_x,2)+pow(Coordinate_3D.getY()*100-target_y,2));

		double finish_yaw_data = (pow(line_a,2)-(pow(line_b,2)+pow(line_c,2)))/(-2*line_b*line_c);
		double finish_yaw = acos( finish_yaw_data )*180.0/M_PI;

		// 직선의 방적식 : (0,0)과 현재위치 //
		// 직선의 위에 있으면 시계방향, 아래있으면 반시계 방향 //
		double where_is_point = target_y - (Coordinate_3D.getY()/Coordinate_3D.getX())*target_x;
		double destination_degree = 0.0;
		if ( where_is_point > 0 )
			destination_degree = middle_yaw - finish_yaw;
		else
			destination_degree = middle_yaw + finish_yaw;
		if ( destination_degree <-180.0 )
			destination_degree = destination_degree + 360.0;
		else if	( destination_degree > 180.0 )
			destination_degree = destination_degree - 360.0;

		std::cout<<"Map 으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
		std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
		std::cout<<"축 회전 각 [degree] (roll, pitch, yaw)"<<std::endl;
		std::cout<<"	("<<roll*180.0/M_PI<<", "<<pitch*180.0/M_PI<<", "<<yaw*180.0/M_PI<<")"<< std::endl;
		std::cout << destination_degree << std::endl;
		
		project_ros_cpp::nano_control nano_order;
		if ( (yaw*180.0/M_PI>destination_degree-5) && (yaw*180.0/M_PI<destination_degree+5) )
		{
			// 회전 정지
			std::cout << "회전 정지" << std::endl;
			nano_order.move_message = 5;
			nano_move_pub.publish(nano_order);
			break;
		}		
		else if ( yaw*180.0/M_PI < destination_degree )
		{
			// 좌회전
			std::cout << "좌회전" << std::endl;
			nano_order.move_message = 7;
			nano_move_pub.publish(nano_order);
			sleep(0.1);
			nano_order.move_message = 5;
			nano_move_pub.publish(nano_order);
			sleep(0.5);
		}
		else if ( yaw*180.0/M_PI > destination_degree  )
		{
			// 우회전
			std::cout << "우회전" << std::endl;
			nano_order.move_message = 6;
			nano_move_pub.publish(nano_order);
			sleep(0.1);
			nano_order.move_message = 5;
			nano_move_pub.publish(nano_order);
			sleep(0.5);
		}
	}
}

void move_nano()
{
	ros::NodeHandle nh;
	ros::Publisher nano_move_pub = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);

	tf::TransformListener tfl;
	tf::StampedTransform my_test_transform;

	std::string start = std::string("/map"); 
	std::string move = std::string("/base_footprint");

	project_ros_cpp::nano_control nano_order;

	double target_distance = 0.0;
	while (ros::ok())
	{
		tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
		tfl.lookupTransform(start, move, ros::Time(), my_test_transform);
		tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

		target_distance = sqrt( pow(Coordinate_3D.getX()*100-target_x,2) + pow(Coordinate_3D.getY()*100-target_y,2) );

		std::cout<<"Map 으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
		std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
		std::cout<< target_distance <<std::endl;

		if ( target_distance > 30 )
		{
			std::cout << "직진" << std::endl;
			nano_order.move_message = 1;	
			nano_move_pub.publish(nano_order);
		}
		else
		{
			std::cout << "직진 정지" << std::endl;
			nano_order.move_message = 5;
			nano_move_pub.publish(nano_order);
			break;	
		}
	}
}

int main(int argc, char **argv)
{
	ros::init(argc, argv, "find_yaw");

	target_x = 0.0;
	target_y = 50.0;
	find_yaw();
	move_nano();

	target_x = 50.0;
	target_y = 50.0;
	find_yaw();
	move_nano();

	target_x = 100.0;
	target_y = 100.0;
	find_yaw();
	move_nano();

	target_x = 0.0;
	target_y = 0.0;
	find_yaw();
	move_nano();

	return 0;
}

