LIDAR_Install

ROS란?
robot operating system : 로봇용 공개소스 메타 운영체제입니다.
http://wiki.ros.org/ko/ROS/Introduction

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ROS - Melodic 설치
http://wiki.ros.org/melodic/Installation/Ubuntu

pc가 packages.ros.org로부터 ROS관련 소프트웨어를 받을 수 있도록 설정
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'

다운로드 받는 패키지가 신뢰 할 수 있다는 것을 확인하기 위해 key값을 설정
sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654

sudo apt-get update
sudo apt-get install -y liblua5.2-dev libgflags-dev libsuitesparse-dev libgoogle-glog-dev
sudo apt install ros-melodic-desktop-full
	오류나는경우
	sudo apt-get --fix-broken install
sudo rosdep init
rosdep update
(rosdep은 ROS 구동에 필요한 요소를 쉽게 설치하도록 돕는 역할.)

echo "source /opt/ros/melodic/setup.bash" >> ~/.bashrc
source ~/.bashrc
	이렇게 echo를 사용해 bashrc에 추가하면 터미널이 켜질때마다 setup.bash를 수행한다.
	지금 켠 터미널에만 한번 적용하고, 그 터미널을 껐다가 다시 켰을때는 영향을 안주려면
	echo를 쓰지말고 바로 source /opt/ros/melodic/setup.bash 하면 된다.
	여기선 echo로 추가해놓는것을 권장합니다.
sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential
	의존성 패키지 설치 오류가 발생하면 필요 모듈을 아래에서 다운로드 하고 위 명령어를 다시 수행합니다.
	http://repos.ros.org/repos/ros_bootstrap/pool/main/p/python-rospkg-modules/
	sudo dpkg -i --force-overwrite python-rospkg-modules_1.1.10-1_all.deb


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Cartographer ROS 설치
https://google-cartographer-ros.readthedocs.io/en/latest/compilation.html

sudo apt-get install -y python-wstool python-rosdep ninja-build
mkdir Google_Cartographer && cd Google_Cartographer && wstool init src #Tag1#
wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstall
wstool update -t src
src/cartographer/scripts/install_proto3.sh
sudo rosdep init
	Cartographer ROS를 사용해야 하는데 위에서 설치하느라 sudo rosdep init했기때문에 아래와 같은 에러가 나온다.
	The command ‘sudo rosdep init’ will print an error if you have already executed it since installing ROS. This error can be ignored.
	해당 위치로 이동해서 파일을 삭제하고 다시 sudo rosdep init한다.
	sudo rm -rf /etc/ros/rosdep/sources.list.d/20-default.list && sudo rosdep init
rosdep update
	오류시 : sudo rosdep fix-permissions 입력하고 다시 rosdep update
cd ~/Google_Cartographer && sudo rosdep install --from-paths src --ignore-src --rosdistro=${ROS_DISTRO} -y
	오류시 : #Tag1# 으로 돌아가서 src 폴더 지우고  wstool init src 부터 다시한다.
catkin_make_isolated --install --use-ninja

source devel_isolated/setup.bash
echo "source ~/Google_Cartographer/devel_isolated/setup.bash" >> ~/.bashrc
source ~/.bashrc

참고 : 헤더파일 위치 : cd /opt/ros/melodic/include

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

0. 설치 확인을 위한 터틀심 예제
roscore # 터미널 1 #
rosrun turtlesim turtlesim_node # 터미널 2 #
rosrun turtlesim turtle_teleop_key # 터미널 3 #

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

1. Google_Cartographer 예제

cd && mkdir carto_with_yd && cd carto_with_yd && mkdir src && cd src
git clone https://github.com/YDLIDAR/ydlidar_ros.git
cd ydlidar_ros && git checkout X2
cd && cd carto_with_yd && catkin_make
source devel/setup.bash
echo "source ~/carto_with_yd/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc
cd && sudo vi .bashrc 입력해서 가장 마지막줄에 source ~/carto_with_yd/devel/setup.bash 가 있어야한다.
터미널 재부팅

cd && cd carto_with_yd/src
git clone https://github.com/msadowski/x2_cartographer.git
git submodule update --init
// 모든 의존성 패키지 포함시키는 명령어이다.
// 현재 src안에 cartographer가 없어서 다른곳에 깔려있으니까 활용하려고 아래 명령어를 입력한다.
sudo rosdep install --from-paths src --ignore-src --rosdistro melodic -r -y
터미널 재부팅

roscd ydlidar/startup
sudo chmod 0777 *
sudo sh initenv.sh
LIDAR 와 Jetson tx2의 usb를 연결했다가 LIDAR가 돌아가면 빼고 다시 usb를 연결한다.

roslaunch carto_mapper mapper.launch # 터미널 1 #
rosrun ydlidar ydlidar_client # 터미널 2 #
RViz 켜지면 좌측 하단의 ADD클릭, Map 클릭, Topic /map으로 선택
더 필요한 버튼은 ADD 해서 추가한다.

x2.lua의 설정은 수정후 catkin_make 필요없다.
~/carto_with_yd/src/x2_cartographer/carto_mapper/config
x2.lua 내용
TRAJECTORY_BUILDER_2D.num_accumulated_range_data = 360 // 이 갯수를 적당히 조정해야
  num_subdivisions_per_laser_scan = 360, // 이 값을 늘렸을때 RViz로 볼수있다.

ydlidar_client.cpp, ydlidar_node.cpp의 설정은 수정 후 catkin_make 필요하다.
cd && cd carto_with_yd && catkin_make
~/carto_with_yd/src/ydlidar_ros/src
ydlidar_node.cpp 내용
	if(degree > -180 && degree< 180) // 터미널에서 보여줄 정보 -180 ~ 180










////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

2-1. YDLIDAR에서 제공하는 예제 1
#터미널에서 측정 값 출력하기#
YDLIDAR X2
공식홈페이지 : http://www.ydlidar.com/download
예제 링크 : https://github.com/YDLIDAR/ydlidar_ros
공식 홈페이지 - X2 - Ros 다운로드 -YDLIDAR ROS Manual

예제를 실행할 폴더인 YDLIDAR와 소스폴더인 src를 만듭니다.
cd && mkdir -p ~/YDLIDAR/src && cd ~/YDLIDAR/src

catkin 명령어를 사용해서 YDLIDAR 폴더를 ROS Workspace로 지정합니다.
catkin_init_workspace

catkin 명령어를 사용해서 ROS를 사용할 환경을 빌드합니다.
cd ~/YDLIDAR && catkin_make

#참고#
catkin : catkin은 ROS의 빌드 시스템이다.
ROS빌드 시스템은 기본적으로 CMake(Cross Platform Make)를 이용한다.
CMake를 ROS에 맞도록 수정한 빌드 환경이 catkin이다.
빌드 환경은 CMakeList.txt를 수정하여 구성한다.

현재 만든 Workspace 환경을 터미널이 켜질때마다 등록한다.
echo "source ~/YDLIDAR/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc

YDLIDAR의 공식 예제를 git에서 clone한다.
cd ~/YDLIDAR/src && git clone https://github.com/YDLIDAR/ydlidar_ros
cd ~/YDLIDAR/src/ydlidar_ros
git checkout X2
	ydlidar_ros 폴더로 이동후 X2 제품에 해당하는 X2 브랜치로 이동하는 git 명령어
	git 버전관리와 관련된 것으로 X2에 해당하는 버전인 X2로 설정시 이에 맞춰 레포지토리의 내용들이 모두 바뀐다.

cmake명령어를 통해 파일을 생성합니다. 
cd ~/YDLIDAR && catkin_make

ydlidar의 시리얼 포트 alias로 /dev/ydlidar를 만들어준다.
initenv.sh 실행후 LIDAR와 jetson을 연결한 usb포트를 한번 빼고 다시 연결한다.
roscd ydlidar/startup
sudo chmod 0777 *
sudo sh initenv.sh

## 실행 시작 ##
roscore # 터미널 1 #
roslaunch ydlidar lidar.launch # 터미널 2 #
rosrun ydlidar ydlidar_client # 터미널 3 #

2-2. rviz로 시각화
# 모든 터미널 종료한다. #
# .launch 파일은 여러개의 노드를 실행시켜준다. #
roslaunch ydlidar lidar_view.launch 

## 사용된 명령어 정리 ##
roscore : ROS Master를 실행하는 명령어. 같은 네트워크라면 다른 컴퓨터에서 실행가능.
단 멀티 ROS코어를 지원하는 특수한 경우를 제외하고, ROS코어는 동일 네트워크에서 하나만 구동하게 되어있음
Master : 노드와 노드 사이의 연결 및 메시지 통신을 위한 네임 서버, 마스터가 없으면 ROS노드간 메시지, 토픽등의 통신을 할 수 없다.
node : 최소 단위의 ROS 실행 프로세서, ROS에서는 하나의 기능을 하나의 노드에 구현하도록 권장함.
rosrun : ROS의 기본적인 실행 명령어, 패키지에서 하나의 노드를 실행하는데 사용된다.
roslaunch : 한번에 복수개의 노드를 실행하는 명령어

참고 : lidar_node와 lidar_client의 소스코드 위치 ~/Melodic/src/ydlidar_ros/src

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

3. Google에서 녹화해놓은 카토그래퍼 예제 불러오기
source install_isolated/setup.bash
wget -P ~/Downloads https://storage.googleapis.com/cartographer-public-data/bags/backpack_2d/cartographer_paper_deutsches_museum.bag
roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=${HOME}/Downloads/cartographer_paper_deutsches_museum.bag
위치 : cd ~/catkin_ws/src/cartographer_ros/cartographer_ros/launch
실행시 라이더의 수평각도가 변하면 안된다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

4. 직접 cpp 패키지와 노드 만들기
https://cafe.naver.com/openrt/3043

cd && mkdir my_cpp_test && cd my_cpp_test && mkdir src && cd src
이때 src는 비워져있어야한다. 다른 예제(카토그래퍼 등..) 있으면 안됨

catkin_create_pkg my_cpp_package std_msgs roscpp
	위 명령어를 수행하면 my_cpp_test/src 아래 my_cpp_package 폴더가 생긴다.
	my_cpp_package를 만들고 의존하는 패키지로 std_msgs와 roscpp를 추가한다는 뜻
	std_msgs : ROS의 표준 메시지 패키지
	roscpp : c/c++을 사용하기 위한 라이브러리
	catkin_create_pkg my_cpp_package 까지만 입력해서 패키지 생성 후 package.xml 에 직접 입력해도 된다.
cd my_cpp_package 해서 생성된 폴더들을 살펴본다.
	include : 인클루드 폴더
	src : 소스코드 폴더
	CMakeLists.txt : 빌드 설정 파일
	package.xml : 패키지 설정 파일


Publisher(값 보내기)와 Subscriber(값 받기)를 만들기 위한 수정사항
4-1. vi package.xml
#######################################################################################################
비슷한 내용이 담긴 위치에 아래 내용을 추가한다.
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
#######################################################################################################

4-2. vi CMakeList.txt
#######################################################################################################
# find_package를 아래 와 같이 수정한다. #
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  message_generation
)

# catkin_package위에 아래 내용을 추가한다. #
add_message_files(FILES my_msg_setting.msg)
generate_messages(DEPENDENCIES std_msgs)
add_executable(my_cpp_publisher src/my_cpp_publisher.cpp)
target_link_libraries(my_cpp_publisher ${catkin_LIBRARIES})
add_dependencies(my_cpp_publisher my_cpp_test_package_generate_messages_cpp)
add_executable(my_cpp_subscriber src/my_cpp_subscriber.cpp)
target_link_libraries(my_cpp_subscriber ${catkin_LIBRARIES})
add_dependencies(my_cpp_subscriber my_cpp_test_package_generate_messages_cpp)

# catkin_package의 주석을 아래와 같이 해제한다. #
catkin_package(
  #INCLUDE_DIRS include
  LIBRARIES my_test_package
  CATKIN_DEPENDS roscpp std_msgs
  #DEPENDS system_lib
)

# include_directories의 내용을 다음과 같이 수정한다. #
# include : include 폴더이다. 빌드 후 헤더가 여기에 담긴다. #
# ${catkin_INCLUDE_DIRS} : ROS 기본 헤더 경로 #
include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)
#######################################################################################################

4-3. 위의 vi CMakeList.txt에서 추가한 
add_message_files(FILES my_msg_setting.msg) 옵션은
노드가 사용할 my_msg_setting.msg를 빌드할때 포함하란 뜻이다.
my_msg_setting.msg는 현재는 없으므로 생성해준다.

cd ~/my_cpp_test/src/my_cpp_package
mkdir msg && cd msg && vi my_msg_setting.msg
int32 data 입력하고 저장. (int32형으로 data를 선언한다는 뜻)
#######################################################################################################

4-4-1. 위의 vi CMakeList.txt에서 추가한
add_executable(my_cpp_publisher src/my_cpp_publisher.cpp) 와
add_executable(my_cpp_subscriber src/my_cpp_subscriber.cpp) 옵션은 
my_cpp_publisher.cpp를 빌드해서 my_cpp_publisher를 만들라는 뜻이다.
my_cpp_publisher.cpp, my_cpp_subscriber.cpp는 현재 없으므로 생성해준다.

cd ~/my_cpp_test/src/my_cpp_package/src
vi my_cpp_publisher.cpp 하고 아래 내용 입력
#######################################################################################################
#include "ros/ros.h" // ROS 기본 헤더파일
#include "my_cpp_package/my_msg_setting.h"
// 현재는 없는 파일이다. 빌드후 자동 생성된다.
// 이름은 CMakeLists.txt 에서 추가한 add_message_files(FILES my_msg_setting.msg)과 이름이 같아야 한다.


// 메인 함수 시작
int main(int argc, char **argv)
{
  ros::init(argc, argv, "my_publisher_node"); // 노드명 초기화
  ros::NodeHandle nh; // ROS 시스템과 통신을 위한 노드 핸들 선언

  // Publisher 선언
  // my_cpp_package 패키지의 my_msg_setting.msg파일을 이용한 발행자 my_cpp_pub을 작성한다.
  // 토픽명은 "my_package_msg" 이며, 발행자 큐(queue) 사이즈를 100개로 설정한다는 것이다.
  ros::Publisher my_cpp_pub = nh.advertise<my_cpp_package::my_msg_setting>("my_package_msg", 100);


  // 루프 주기를 설정한다. "10" 이라는 것은 10Hz를 말하는 것으로 0.1초 간격으로 반복된다.
  // 1이니까 1hz, 1초간격으로 반복한다.
  ros::Rate loop_rate(1);


  int count = 0; // 메시지에 사용될 변수 선언
  while (ros::ok())
  {
    my_cpp_package::my_msg_setting msg; // my_msg_setting.msg에서 지정한 형식으로 msg 라는 메시지를 선언

    //msg.stamp = ros::Time::now();
    msg.data = count;
    // count 라는 변수의 값을 msg.data에 저장
    // 이때 .data에 저장 할 수 있는 이유는 my_msg_setting.msg를 int32 'data' 라고 만들었기 때문이다.
    // abcd라고 만들었으면 msg.abcd = count; 라고 저장했을것이다.

    ROS_INFO("send msg = %d", count); // ROS_INFO 라는 ROS 함수를 이용해서 count 변수를 표시해본다.
    //ROS_INFO("send msg = %d", ros::Time::now());
    my_cpp_pub.publish(msg); // 메시지를 발행한다. 위에서 설정한 1Hz 간격으로 발행된다.

    loop_rate.sleep(); // 위에서 정한 hz에 의해 슬립에 들어간다.
    ++count; // count 변수 1씩 증가
  }

  return 0;
}
#######################################################################################################

4-4-2. vi my_cpp_subscriber.cpp 하고 아래 내용 입력
#######################################################################################################
#include "ros/ros.h"
#include "my_cpp_package/my_msg_setting.h"
// 메시지 콜백함수를 사용자가 직접 만들어본다.
// 전달 받은 메세지는 위에서 보낸 msg.data = count; 이다.


void msgCallback(const my_cpp_package::my_msg_setting::ConstPtr& msg)
{
  ROS_INFO("recieve msg: %d", msg->data); // msg에서 data를 꺼낸다.
}

int main(int argc, char **argv) // 노드 메인 함수
{
  ros::init(argc, argv, "my_subscriber_node"); // 노드명 초기화

  ros::NodeHandle nh; // ROS 시스템과 통신을 위한 노드 핸들 선언

  // Subscriber 선언
  // my_package_msg 토픽으로부터 100개의 큐를 msgCallback로 보낸다.
  ros::Subscriber my_cpp_sub = nh.subscribe("my_package_msg", 100, msgCallback);

  ros::spin(); // 콜백함수 호출을 위한 함수로써, 메시지가 수신되기를 대기, 수신되었을 경우 콜백함수를 실행한다.

  return 0;

}
#######################################################################################################

4-5. 빌드를 수행한다. 
cd ~/my_cpp_test && catkin_make
echo "source ~/my_cpp_test/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc
모든 터미널을 종료한다.
roscore # 터미널 1 #
rosrun my_test_package my_msg_publisher # 터미널 2 #
rosrun my_test_package my_msg_subscriber # 터미널 3 #

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임패드로 Jetson nano 움직이는 예제 1

You need to prepare an SD card which should be at least 64G 
User Etcher software to write image (unzip above) to SD card.

나노를 분리한 상태로 건전지의 전원을 충전한다.
충전이 완료되면 충전기의 전원을 반드시 뽑는다.

젯봇에서 분리된 상태의 나노를 나노 전원 입력 커넥터로 먼저 킨다. (나노의 초기 아이디, 비밀번호 : jetbot)
와이파이를 연결하고 나노의 전원을 끈다.
나노 전원 입력 커넥터를 반드시 분리한다.

젯봇을 만든다.
젯봇의 스위치를 ON으로 만들어서 나노를 다시 킨다.
OLED에 IP주소가 나온다.

젯봇의 Public IP를 획득하여
공유기에서 포트 포워딩 시킨다.
내부아이피주소 입력, 외부포트 8282
내부포트 8888
http://<젯봇의 Public IP>:8282 이렇게 접속 가능하다.

# 기본 젯봇 움직이기 #
책상에 올려놓지 말고 바닥의 넓은 공간에 내려놓습니다.
아래 위치로 이동해서 파일을 엽니다.
 ~/Notebooks/basic_motion/
basic_motion.ipynb

# 원격 조종 예제 #
~/Notebooks/teleoperation/
teleoperation.ipynb
Connect USB adapter to PC

게임패드 설정
게임패드는 두가지 모드를 지원한다.
1. PC/PS3/Andorid mode (초기값)
2. XBox 360 mode. 
예제는 XBox 360모드로 진행한다.
홈 버튼을 7초동안 누른다.
left joystick is mapped to axes[0] and axes[1]
right joystick is mapped to axes[2] and axes[3]

# 학습된 충돌방지 예제 #
1. 벽에 대한 데이터 수집
~/Notebooks/collision_avoidance/
data_collection.ipynb	
2. 학습 ( Neural network 사용 )
tain_model.ipynb
3. 실행
live_demo.ipynb

# 오브젝트 트래킹 #
~/Notebooks/object_following/ 폴더에 아래의 미리 학습된 자료 다운로드
https://drive.google.com/file/d/1RnNBHPDphIOWwHCSfeMCWQ7XN3w3tKFD/view
( 충돌 방지로도 잘 학습된 자료이다. )
live_demo.ipynb

# 라인 트래킹 #
~/Notebooks/road_following/
data-collection.ipynb
	


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

참고
직접 코딩
https://github.com/yangfuyuan/ydlidar_sdk
한글강의
https://github.com/robotpilot/ros-seminar
영어 튜토리얼
http://wiki.ros.org/ROS/Tutorials
WaveShae 예제
https://www.waveshare.com/wiki/JetBot_AI_Kit
네이버 한글 강좌 (오로카)
https://cafe.naver.com/openrt/2360
