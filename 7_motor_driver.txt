// 1. waveshare jetbot nano 모터 드라이버 분리 시키기 //
###############################################################################################################################
// 파이썬에 드라이버 설치 //
python3 -m pip install traitlets
python3 -m pip install Adafruit_MotorHAT
// 분리할 소스 //
https://github.com/waveshare/jetbot.git 
git clone https://github.com/waveshare/jetbot.git 안에 들어있는
motor.py 와 robot.py를 활용한다.

cd && cd project_black/src/project_ros_python/include && vi motor.py
///////////////////////////////////////////////////////////////
import atexit
from Adafruit_MotorHAT import Adafruit_MotorHAT
import traitlets
from traitlets.config.configurable import Configurable


class Motor(Configurable):

    value = traitlets.Float()
    
    # config
    alpha = traitlets.Float(default_value=1.0).tag(config=True)
    beta = traitlets.Float(default_value=0.0).tag(config=True)

    def __init__(self, driver, channel, *args, **kwargs):
        super(Motor, self).__init__(*args, **kwargs)  # initializes traitlets

        self._driver = driver
        self._motor = self._driver.getMotor(channel)
        atexit.register(self._release)
        
    @traitlets.observe('value')
    def _observe_value(self, change):
        self._write_value(change['new'])

    def _write_value(self, value):
        """Sets motor value between [-1, 1]"""
        mapped_value = int(255.0 * (self.alpha * value + self.beta))
        speed = min(max(abs(mapped_value), 0), 255)
        self._motor.setSpeed(speed)
        if mapped_value < 0:
            self._motor.run(Adafruit_MotorHAT.FORWARD)
        else:
            self._motor.run(Adafruit_MotorHAT.BACKWARD)

    def _release(self):
        """Stops motor by releasing control"""
        self._motor.run(Adafruit_MotorHAT.RELEASE)
///////////////////////////////////////////////////////////////


cd && cd project_black/src/project_ros_python/include && vi robot.py
///////////////////////////////////////////////////////////////
import time
import traitlets
from traitlets.config.configurable import SingletonConfigurable
from Adafruit_MotorHAT import Adafruit_MotorHAT
from motor import Motor


class Robot(SingletonConfigurable):
    
    left_motor = traitlets.Instance(Motor)
    right_motor = traitlets.Instance(Motor)

    # config
    i2c_bus = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_channel = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    right_motor_channel = traitlets.Integer(default_value=2).tag(config=True)
    right_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    
    def __init__(self, *args, **kwargs):
        super(Robot, self).__init__(*args, **kwargs)
        self.motor_driver = Adafruit_MotorHAT(i2c_bus=self.i2c_bus)
        self.left_motor = Motor(self.motor_driver, channel=self.left_motor_channel, alpha=self.left_motor_alpha)
        self.right_motor = Motor(self.motor_driver, channel=self.right_motor_channel, alpha=self.right_motor_alpha)
        
    def set_motors(self, left_speed, right_speed):
        self.left_motor.value = left_speed
        self.right_motor.value = right_speed
        
    def forward(self, speed=1.0, duration=None):
        self.left_motor.value = speed
        self.right_motor.value = speed

    def backward(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = -speed

    def left(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = speed

    def right(self, speed=1.0):
        self.left_motor.value = speed
        self.right_motor.value = -speed

    def stop(self):
        self.left_motor.value = 0
        self.right_motor.value = 0
///////////////////////////////////////////////////////////////
###############################################################################################################################

























// 2. 예제 코드 //
###############################################################################################################################
/////////////////////////////////////////////////////////
#!/usr/bin/env python3

from robot import Robot
import time

# 방향 조절
# robot.left
# robot.right
# robot.forward
# robot.backwards

robot = Robot()
robot.left(speed=0.3) # 왼쪽 모터 최대 속도의 30%로 지정
robot.left(0.3) # 위와 같은 표현이다.
time.sleep(0.5) # 0.5초 동안 유지한다.
robot.stop()

# 회전 조절
robot.set_motors(0.3, 0.6) # 좌 회전
time.sleep(1.0)
robot.stop()

# 위와 같은 표현
robot.left_motor.value = 0.3
robot.right_motor.value = 0.6
time.sleep(1.0)
robot.left_motor.value = 0.0
robot.right_motor.value = 0.0
/////////////////////////////////////////////////////////
###############################################################################################################################


























// 3. Topic을 Subscribe하여 움직이는 Jetbot nano 드라이버 //
###############################################################################################################################
cd && cd project_black/src/project_ros_python/src && vi nano_move.py
///////////////////////////////////////////////////////////////
#!/usr/bin/env python3

from robot import Robot
import time
import rospy
from project_ros_python.msg import nano_control

robot = Robot()
robot.set_motors(0.0, 0.0)

left_now = 0.0
right_now = 0.0

max_speed = 0.2
change_speed = 0.001
rotation_speed = 0.15
forward_change_speed = 0.05

# 최대 1.0 #
# 코드를 잘못 작성하면 1.0 이상으로 올라가므로 주의한다. #

def callback(data):
	global left_now
	global right_now 
	move_value = data.move_message
	rospy.loginfo("I heard from keyboard %d", move_value)
	
	if ( move_value == 1 ):
		# 직진
		robot.set_motors(max_speed, max_speed)
		left_now = max_speed
		right_now = max_speed

	if ( move_value == 2 ):
		# 좌회전
		if ( (left_now == 0.0) and (right_now == 0.0) ):
			robot.set_motors(max_speed-change_speed, max_speed)
			left_now = max_speed-change_speed
			right_now = max_speed
		else:
			if (left_now >= max_speed):
				robot.left_motor.value = max_speed - change_speed
				left_now = max_speed - change_speed
			elif (left_now <= 0.0):
				robot.left_motor.value = 0.0
				left_now = 0.0
			else:
				robot.left_motor.value = left_now - change_speed
				left_now = left_now - change_speed

			if (right_now >= max_speed):
				robot.right_motor.value = max_speed
				right_now = max_speed
			elif (right_now <= 0.0):
				robot.right_motor.value = 0.0
				right_now = 0.0
				robot.right_motor.value = right_now + change_speed
				right_now = right_now + change_speed
			else :
				robot.right_motor.value = right_now + change_speed
				right_now = right_now + change_speed

	if ( move_value == 3 ):
		# 우회전
		if ( (left_now == 0.0) and (right_now == 0.0) ):
			robot.set_motors(max_speed, max_speed-change_speed)
			left_now = max_speed
			right_now = max_speed-change_speed
		else:
			if (left_now >= max_speed):
				robot.left_motor.value = max_speed
				left_now = max_speed
			elif (left_now <= 0.0):
				robot.left_motor.value = 0.0
				left_now = 0.0
				robot.left_motor.value = left_now + change_speed
				left_now = left_now + change_speed
			else:
				robot.left_motor.value = left_now + change_speed
				left_now = left_now + change_speed

			if (right_now >= max_speed):
				robot.right_motor.value = max_speed - change_speed
				right_now = max_speed - change_speed
			elif (right_now <= 0.0):
				robot.right_motor.value = 0.0
				right_now = 0.0
			else:
				robot.right_motor.value = right_now - change_speed
				right_now = right_now - change_speed

	if ( move_value == 4 ):
		# 후진
		robot.set_motors(-max_speed, -max_speed)
		left_now = -max_speed
		right_now = -max_speed

	if ( move_value == 5 ):
		# 정지
		robot.set_motors(0.0, 0.0)		
		left_now = 0.0
		right_now = 0.0

	if ( move_value == 6 ):
		# 제자리 우회전
		robot.set_motors(rotation_speed, -rotation_speed)		
		left_now = rotation_speed
		right_now = -rotation_speed

	if ( move_value == 7 ):
		# 제자리 좌회전
		robot.set_motors(-rotation_speed, rotation_speed)		
		left_now = -rotation_speed
		right_now = rotation_speed

	if ( move_value == 8 ):
		# 직진 (점진적 증가)
		if ( left_now >= max_speed ):
			robot.left_motor.value = max_speed
			left_now = max_speed
		elif ( left_now <= 0.0 ):
			robot.left_motor.value = 0.0 + forward_change_speed
			left_now = 0.0 + forward_change_speed
		else:
			robot.left_motor.value = left_now + forward_change_speed
			left_now = left_now + forward_change_speed

		if ( right_now >= max_speed ):
			robot.right_motor.value = max_speed
			right_now = max_speed
		elif ( right_now <= 0.0 ):
			robot.right_motor.value = 0.0 + forward_change_speed
			right_now = 0.0 + forward_change_speed
		else:
			robot.right_motor.value = right_now + forward_change_speed
			right_now = right_now + forward_change_speed
		

def wait_listen():
	rospy.init_node('move_subscriber_node', anonymous=True)
	rospy.Subscriber('ros_move_topic', nano_control, callback)
	rospy.spin()

if __name__=='__main__':
	wait_listen()
///////////////////////////////////////////////////////////////
cd && cd project_black/src/project_ros_python && vi CMakeLists.txt
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  tf
  message_generation
)

 add_message_files(
   FILES
   get_degree.msg
   nano_control.msg
 )

 generate_messages(
   DEPENDENCIES
   std_msgs
 )

catkin_package(
#  INCLUDE_DIRS include
  LIBRARIES project_ros_python
  CATKIN_DEPENDS roscpp rospy std_msgs tf message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

cd && cd project_black/src/project_ros_python/src && chmod +x nano_move.py
cd && cd project_black && catkin_make

export PYTHONPATH="${PYTHONPATH}:/home/nvidia/project_black/src/project_ros_python/msg"
export PYTHONPATH="${PYTHONPATH}:/home/nvidia/project_black/src/project_ros_python/include"

import sys
sys.path.append("/home/jetbot/project_black/src/project_ros_python/include")

###############################################################################################################################


















// 4. IMU, Google cartograhper TF를 활용하여 목표 지점 보게 만들고 직진 //
############################################################################################################################

cd && cd project_black/src/project_ros_cpp/src && vi rotaion_and_move.cpp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <ros/ros.h>
#include <iostream>
#include "tf/transform_listener.h"
#include "project_ros_cpp/nano_control.h"
#include "project_ros_cpp/get_degree.h"
#include "project_ros_cpp/step_one_flag.h"
#include <unistd.h>
#include <chrono>

#define dot_point 4
double target_xy[dot_point][2]; // 목표위치 x,y
int xy_count = 0;

double target_x = 0.0;
double target_y = 0.0;

bool step_one_rotation_flag = true;
bool make_target_yaw_flag = true;
double destination_yaw = 0.0;
double get_mpu_yaw = 0.0;
double target_yaw = 0.0;
int check_angle_count = 0;

bool step_two_rotation_flag = true;
bool range_flag = true;
bool range_out_flag = true;
double range_out_check = 0.0;
double find_center_yaw =0.0;

bool shutdown_flag = true;

project_ros_cpp::nano_control step_one_order;
project_ros_cpp::nano_control step_two_order;
project_ros_cpp::step_one_flag step_one_done_flag;

std::chrono::system_clock::time_point mean_start;
std::chrono::duration<double> limit_sec;

std::chrono::system_clock::time_point start;
std::chrono::duration<double> sec;

void find_direction()
{	
	double mean_x = 0.0;
	double mean_y = 0.0;
	int mean_count = 0;

	if (xy_count < (sizeof(target_xy)/sizeof(target_xy[0])) )
	{
		target_x = target_xy[xy_count][0];
		target_y = target_xy[xy_count][1];
		++xy_count;
		////////////////////////////////////////////////////////////////////////
		tf::TransformListener tfl;
		tf::StampedTransform my_test_transform;

		std::string start = std::string("/map"); 
		std::string move = std::string("/base_footprint");
		
		tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
		tfl.lookupTransform(start, move, ros::Time(), my_test_transform);

		double yaw, pitch, roll;
		my_test_transform.getBasis().getRPY(roll, pitch, yaw);
		tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();
		////////////////////////////////////////////////////////////////////////


		////////////////////////////////////////////////////////////////////////
		mean_start = std::chrono::system_clock::now();
		limit_sec = std::chrono::system_clock::now() - mean_start;

		while ( limit_sec.count() < 0.3 )
		{
			limit_sec = std::chrono::system_clock::now() - mean_start;
			mean_x = mean_x + Coordinate_3D.getX();
			mean_y = mean_y + Coordinate_3D.getY();
			++mean_count;
		}

		mean_x = mean_x/mean_count;
		mean_y = mean_y/mean_count;

		if ( mean_count == 0 )
		{
			mean_x = Coordinate_3D.getX();
			mean_y = Coordinate_3D.getY();
		}
		////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////
		/*
		mean_x = Coordinate_3D.getX();
		mean_y = Coordinate_3D.getY();
		*/
		////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// 0. 이미 목표지점인지 확인한다. //
		double distance = sqrt(pow(mean_x*100-target_x,2)+pow(mean_y*100-target_y,2));
		if ( distance < 10.0 )
		{
			step_two_rotation_flag= false;
			std::cout << "reached !!! : " << std::endl;
		}

		// 1. nano의 yaw를 0으로 만들 yaw값을 구한다.
			// nano좌표의 Y가 0보다 작은경우 yaw는 반드시 0 ~ -180 사이의 값을 반환한다.
			// nano좌표의 Y가 0보다 큰경우 yaw는 반드시 0 ~ +180 사이의 값을 반환한다.
		double nano_zero_yaw = -yaw*180.0/M_PI;
		//std::cout << "nano_zero_yaw : " << nano_zero_yaw << std::endl;

		// 2. nano의 yaw가 0일때, 목표지점까지의 yaw를 구한다.
		double zero_to_target = (atan2((target_y-mean_y*100.0), (target_x-mean_x*100.0))*180.0/M_PI);
		//std::cout << "zero_to_target : " << zero_to_target << std::endl;

		// 3. 현재 yaw에서 회전할 yaw를 구한다.
			// 180도 이상의 회전을 방지하기 위해 아래와 같이 정의한다.
		destination_yaw = nano_zero_yaw + zero_to_target;
		if ( destination_yaw < -180.0 )
		{
			destination_yaw = destination_yaw + 360.0;
		}
		else if ( destination_yaw > 180.0 )
		{
			destination_yaw = destination_yaw - 360.0;
		}
		//std::cout << "destination_yaw : " << destination_yaw << std::endl;
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	}
	else
	{
		shutdown_flag = false;
	}

}

void do_rotation(const project_ros_cpp::get_degree::ConstPtr& data)
{
	get_mpu_yaw = data->yaw;
	//std::cout << "do_rotation start" << std::endl;

	if ( step_one_rotation_flag )
	{
		if ( make_target_yaw_flag )
		{
			if ( get_mpu_yaw > 180.0 )
			{
				get_mpu_yaw = get_mpu_yaw - 360.0;
			}
			else if ( get_mpu_yaw < -180.0 )
			{
				get_mpu_yaw = get_mpu_yaw + 360.0;
			}
			
			target_yaw = destination_yaw + get_mpu_yaw;

			if ( target_yaw > 180.0 )
			{
				target_yaw = target_yaw - 360.0;
			}
			else if ( target_yaw < -180.0 )
			{
				target_yaw = target_yaw + 360.0;
			}
			
			make_target_yaw_flag = false;
		}

		double gap = target_yaw - get_mpu_yaw;

		if ( gap < -180.0 )
		{
			gap = gap + 360.0;
		}
		else if ( gap > 180.0 )	
		{
			gap = gap - 360.0;
		}

		if ( (gap<10.0) && (gap>-10.0) )
		{
			std::cout << "gap : " << gap << " 회전 정지" <<std::endl;
			step_one_order.move_message = 5;
			step_one_rotation_flag = false;		
		}
		else if ( gap>10.0 )
		{
			std::cout << "gap : " << gap << " 제자리 좌회전" <<std::endl;
			step_one_order.move_message = 7;
		}
		else if ( gap<-10.0 )
		{
			std::cout << "gap : " << gap << " 제자리 우회전" <<std::endl;
			step_one_order.move_message = 6;
		}
	}
}







void move_nano(const project_ros_cpp::step_one_flag::ConstPtr& data)
{
	if ( data->done_flag )
	{
		if ( step_two_rotation_flag )
		{
			//std::cout << "move_nano start" << std::endl;

			tf::TransformListener tfl;
			tf::StampedTransform my_test_transform;

			std::string start = std::string("/map"); 
			std::string move = std::string("/base_footprint");

			tfl.waitForTransform(start, move, ros::Time(), ros::Duration(10.0));
			tfl.lookupTransform(start, move, ros::Time(), my_test_transform);
			tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

			// 현재 위치와 이전 위치의 차이를 계산한다. 이전 위치보다 현재 위치가 더 멀면 음수가 된다. = 목표를 향하는것이 아니다. //
			double distance = sqrt(pow(Coordinate_3D.getX()*100-target_x,2)+pow(Coordinate_3D.getY()*100-target_y,2));

			std::cout << "distance : "<< distance << std::endl;

			if ( distance < 10.0 )
			{
				// 목표 범위에 도착한 경우 //
				std::cout << "직진 정지" << std::endl;
				step_two_order.move_message = 5;
				step_two_rotation_flag= false;
			}
			else if ( distance > 10.0 )
			{
				std::cout << "직진" << std::endl;
				step_two_order.move_message = 1;
			}
			
		}
	}
}






int main(int argc, char **argv)
{
	ros::init(argc, argv, "find_yaw");
	ros::NodeHandle nh;
	ros::Subscriber step_one = nh.subscribe("mpu_6050_degree", 1, do_rotation);
	ros::Subscriber step_two = nh.subscribe("step_one_topic", 1, move_nano);
	ros::Publisher move_pub_one = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);
	ros::Publisher move_pub_two = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);
	ros::Publisher step_one_done = nh.advertise<project_ros_cpp::step_one_flag>("step_one_topic", 1);

	for ( int i=0; i<dot_point; i++)
	{
		target_xy[i][0] = 0.0 + 10.0*i;
		target_xy[i][1] = 0.0;
	}

	////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////
	step_one_rotation_flag = true;
	make_target_yaw_flag = true;

	step_two_rotation_flag = true;
	range_flag = true;
	range_out_flag = true;

	find_direction();
	///////////////////////////////////

	while ( ros::ok() )
	{
		if ( step_two_rotation_flag )
		{
			if ( step_one_rotation_flag )
			{
				// 1 목표 지점 향하게 만들기 //
				ros::spinOnce();
				move_pub_one.publish(step_one_order);
			}
			else
			{
				// 2 목표 지점으로 직진하거나 멈추기 //
				std::cout <<"target point : "<< target_x <<", " << target_y <<std::endl;
				step_one_done_flag.done_flag = 1;
				step_one_done.publish(step_one_done_flag);
				ros::spinOnce();
				move_pub_two.publish(step_two_order);
				
    				start = std::chrono::system_clock::now();
				sec = std::chrono::system_clock::now() - start;
				while ( sec.count() < 0.3 )
				{
					sec = std::chrono::system_clock::now() - start;
				}
				step_two_order.move_message = 5;
				move_pub_two.publish(step_two_order);

				///////////////////////////////////
				xy_count = xy_count - 1;
				find_direction();
				step_one_rotation_flag = true;
				make_target_yaw_flag = true;
				step_one_done_flag.done_flag = 0;
				step_one_done.publish(step_one_done_flag);
				///////////////////////////////////
			}
		}
		else
		{
			///////////////////////////////////
			step_one_rotation_flag = true;
			make_target_yaw_flag = true;

			step_two_rotation_flag = true;
			range_flag = true;
			range_out_flag = true;

			find_direction();
			///////////////////////////////////

			if ( !shutdown_flag )
			{
				for ( int i=0; i<5; i++)
				{
					step_two_order.move_message = 5;
					move_pub_two.publish(step_two_order);
				}
				ros::shutdown();
			}
		}

	}
	////////////////////////////////////////////////////////////////////////////////////////

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

nano_move.py : (직진 0.2, 회전 0.15)

cd && cd project_black/src/project_ros_cpp && mkdir msg && cd msg && vi step_one_flag.msg
int32 done_flag

cd && cd project_black/src/project_ros_python/msg 에서
get_degree.msg, nano_control.msg 파일 복사해서 cpp의 msg폴더에 붙여넣기

cd && cd project_black/src/project_ros_cpp && vi package.xml
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>

cd && cd project_black/src/project_ros_cpp && vi CMakeLists.txt
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  tf
  message_generation
)

 add_message_files(
   FILES
   get_degree.msg
   nano_control.msg
   step_one_flag.msg
 )

 generate_messages(
   DEPENDENCIES
   std_msgs
 )

add_executable(rotaion_and_move src/rotaion_and_move.cpp)
target_link_libraries(rotaion_and_move ${catkin_LIBRARIES})
add_dependencies(rotaion_and_move project_ros_cpp_generate_messages_cpp)

catkin_package(
#  INCLUDE_DIRS include
  LIBRARIES project_ros_cpp
  CATKIN_DEPENDS roscpp rospy std_msgs tf message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)
############################################################################################################################






// 5. 최적화 //
#include <ros/ros.h>
#include <iostream>
#include "tf/transform_listener.h"
#include "project_ros_cpp/nano_control.h"
#include "project_ros_cpp/get_degree.h"
#include "project_ros_cpp/step_one_flag.h"
#include "project_ros_cpp/clean_point.h"
#include <unistd.h>
#include <chrono>

#include "std_msgs/MultiArrayLayout.h"
#include "std_msgs/MultiArrayDimension.h"
#include "std_msgs/Int32MultiArray.h"


int xy_count = 0;

int map_origin_x = 0, map_origin_y = 0;

double target_x = 0.0;
double target_y = 0.0;

bool step_one_rotation_flag = true;
bool make_target_yaw_flag = true;
double destination_yaw = 0.0;
double get_mpu_yaw = 0.0;
double target_yaw = 0.0;
int check_angle_count = 0;

bool step_two_rotation_flag = true;
bool range_flag = true;
bool range_out_flag = true;
double range_out_check = 0.0;
double find_center_yaw =0.0;

bool shutdown_flag = true;

#define point_interval 4

project_ros_cpp::nano_control step_one_order;
project_ros_cpp::nano_control step_two_order;
project_ros_cpp::step_one_flag step_one_done_flag;

std_msgs::Int32MultiArray point_data;

std::chrono::system_clock::time_point mean_start;
std::chrono::duration<double> limit_sec;

std::chrono::system_clock::time_point start;
std::chrono::duration<double> sec;

void find_direction(int point_data_set[][2] )
{	
	double mean_x = 0.0;
	double mean_y = 0.0;
	int mean_count = 0;

	if (xy_count < (point_data.data.size()/2) )
	{

		target_x = point_data_set[xy_count][0];
		target_y = point_data_set[xy_count][1];
		++xy_count;

		////////////////////////////////////////////////////////////////////////
		tf::TransformListener tfl;
		tf::StampedTransform my_test_transform;

		std::string start = std::string("/map"); 
		std::string move = std::string("/base_footprint");
		
		mean_start = std::chrono::system_clock::now();
		limit_sec = std::chrono::system_clock::now() - mean_start;

		try
		{
			tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
			tfl.lookupTransform(start, move, ros::Time(), my_test_transform);
			tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

			mean_x = map_origin_x + Coordinate_3D.getX()*100.0/2.0;
			mean_y = map_origin_y - Coordinate_3D.getY()*100.0/2.0;

			std::cout << "현재위치 (i,j) : " << mean_x << ", " << mean_y << std::endl;

			double yaw, pitch, roll;
			my_test_transform.getBasis().getRPY(roll, pitch, yaw);

			///////////////////////////////////////////////////////////////////////////////
			// 흔들릴 경우 대비 //
			/*
			while ( limit_sec.count() < 0.2 )
			{
				limit_sec = std::chrono::system_clock::now() - mean_start;

				tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
				tfl.lookupTransform(start, move, ros::Time(), my_test_transform);
				tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

				mean_x = mean_x + Coordinate_3D.getX();
				mean_y = mean_y + Coordinate_3D.getY();
				++mean_count;
			}

			std::cout << "mean_count !!! : " << mean_count << std::endl;


			if ( mean_count == 0 )
			{
				mean_x = Coordinate_3D.getX();
				mean_y = Coordinate_3D.getY();
				double yaw, pitch, roll;
				my_test_transform.getBasis().getRPY(roll, pitch, yaw);
			}
			else
			{
				mean_x = mean_x/mean_count;
				mean_y = mean_y/mean_count;
				double yaw, pitch, roll;
				my_test_transform.getBasis().getRPY(roll, pitch, yaw);
			}
			*/
			///////////////////////////////////////////////////////////////////////////////


			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// 0. 현재 상태가 목표지점인지 확인한다. //
			double distance = sqrt(pow(mean_x-target_x,2)+pow(mean_y-target_y,2));
			if ( distance < point_interval )
			{
				step_two_rotation_flag= false;
				std::cout << "reached !!! : " << std::endl;
				return;
			}

			// 1. nano의 yaw를 0으로 만들 yaw값을 구한다.
				// nano좌표의 Y가 0보다 작은경우 yaw는 반드시 0 ~ -180 사이의 값을 반환한다.
				// nano좌표의 Y가 0보다 큰경우 yaw는 반드시 0 ~ +180 사이의 값을 반환한다.
			double nano_zero_yaw = -yaw*180.0/M_PI;
			//std::cout << "nano_zero_yaw : " << nano_zero_yaw << std::endl;

			// 2. nano의 yaw가 0일때, 목표지점까지의 yaw를 구한다.
			double zero_to_target = (atan2( -(target_y-mean_y), (target_x-mean_x))*180.0/M_PI);
			//std::cout << "zero_to_target : " << zero_to_target << std::endl;

			// 3. 현재 yaw에서 회전할 yaw를 구한다.
				// 180도 이상의 회전을 방지하기 위해 아래와 같이 정의한다.
			destination_yaw = nano_zero_yaw + zero_to_target;
			if ( destination_yaw < -180.0 )
			{
				destination_yaw = destination_yaw + 360.0;
			}
			else if ( destination_yaw > 180.0 )
			{
				destination_yaw = destination_yaw - 360.0;
			}
			//std::cout << "destination_yaw : " << destination_yaw << std::endl;
			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
		catch(tf2::LookupException& e)
		{
			printf("can't find location\n");
			step_two_rotation_flag= false;
			xy_count = xy_count - 1;
			return;
		}

	}
	else
	{
		step_two_rotation_flag = false;
		shutdown_flag = false;
	}

}

void do_rotation(const project_ros_cpp::get_degree::ConstPtr& data)
{
	get_mpu_yaw = data->yaw;
	//std::cout << "do_rotation start" << std::endl;

	if ( step_one_rotation_flag )
	{
		if ( make_target_yaw_flag )
		{
			if ( get_mpu_yaw > 180.0 )
			{
				get_mpu_yaw = get_mpu_yaw - 360.0;
			}
			else if ( get_mpu_yaw < -180.0 )
			{
				get_mpu_yaw = get_mpu_yaw + 360.0;
			}
			
			target_yaw = destination_yaw + get_mpu_yaw;

			if ( target_yaw > 180.0 )
			{
				target_yaw = target_yaw - 360.0;
			}
			else if ( target_yaw < -180.0 )
			{
				target_yaw = target_yaw + 360.0;
			}
			
			make_target_yaw_flag = false;
		}

		double gap = target_yaw - get_mpu_yaw;

		if ( gap < -180.0 )
		{
			gap = gap + 360.0;
		}
		else if ( gap > 180.0 )	
		{
			gap = gap - 360.0;
		}

		if ( (gap<5.0) && (gap>-5.0) )
		{
			std::cout << "gap : " << gap << " 회전 정지" <<std::endl;
			step_one_order.move_message = 5;
			step_one_rotation_flag = false;		
		}
		else if ( gap>5.0 )
		{
			std::cout << "gap : " << gap << " 제자리 좌회전" <<std::endl;
			step_one_order.move_message = 7;
		}
		else if ( gap<-5.0 )
		{
			std::cout << "gap : " << gap << " 제자리 우회전" <<std::endl;
			step_one_order.move_message = 6;
		}
	}
}







void move_nano(const project_ros_cpp::step_one_flag::ConstPtr& data)
{
	if ( data->done_flag )
	{
		if ( step_two_rotation_flag )
		{
			//std::cout << "move_nano start" << std::endl;

			tf::TransformListener tfl;
			tf::StampedTransform my_test_transform;

			std::string start = std::string("/map"); 
			std::string move = std::string("/base_footprint");

			try
			{
				tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));
				tfl.lookupTransform(start, move, ros::Time(), my_test_transform);
				tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();
	
				// 현재 위치와 이전 위치의 차이를 계산한다. 이전 위치보다 현재 위치가 더 멀면 음수가 된다. = 목표를 향하는것이 아니다. //
				double distance = sqrt(pow(Coordinate_3D.getX()*100-target_x,2)+pow(Coordinate_3D.getY()*100-target_y,2));

				std::cout << "distance : "<< distance << std::endl;

				if ( distance < point_interval )
				{
					// 목표 범위에 도착한 경우 //
					std::cout << "직진 정지" << std::endl;
					step_two_order.move_message = 5;
					step_two_rotation_flag= false;
				}
				else if ( distance > point_interval )
				{
					std::cout << "직진" << std::endl;
					step_two_order.move_message = 1;
				}
			}
			catch(tf2::LookupException& e)
			{
				printf("can't find location\n");
				step_two_rotation_flag= false;
				xy_count = xy_count - 1;
				return;
			}
			
		}
	}
}


void get_mat_check(const std_msgs::Int32MultiArray::ConstPtr& msg)
{

	std::cout << "here 3" << std::endl; 
	
	if ( msg->data.size() > 0 )
	{
		std::cout << "here 4" << std::endl; 
		point_data.data = msg->data;
	}
	std::cout << "here 5" << std::endl; 
}

int main(int argc, char **argv)
{
	ros::init(argc, argv, "find_yaw");
	ros::NodeHandle nh;

	ros::Subscriber step_one = nh.subscribe("mpu_6050_degree", 1, do_rotation);
	ros::Subscriber step_two = nh.subscribe("step_one_topic", 1, move_nano);

	ros::Publisher move_pub_one = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);
	ros::Publisher move_pub_two = nh.advertise<project_ros_cpp::nano_control>("ros_move_topic", 1);
	ros::Publisher step_one_done = nh.advertise<project_ros_cpp::step_one_flag>("step_one_topic", 1);

	while ( ros::ok() )
	{
		std::cout << "here 1" << std::endl;

		std_msgs::Int32MultiArray::ConstPtr msg = ros::topic::waitForMessage<std_msgs::Int32MultiArray>("clean_point_topic",nh,ros::Duration(1.0));
		if (msg)
		{
			std::cout << "here 2" << std::endl;
			get_mat_check(msg);
			std::cout << "here 6" << std::endl;
			break; 
		}

	}
	

	map_origin_y = point_data.data.back();
	point_data.data.pop_back();
	map_origin_x = point_data.data.back();
	point_data.data.pop_back();

	std::cout << "map : " << map_origin_x << ", " << map_origin_y << std::endl;


	int point_data_set[point_data.data.size()/2][2];

	int j = 0;
	for ( int i=0; i<(point_data.data.size()/2) ; i++ )
	{
		point_data_set[i][0] = point_data.data[j];
		point_data_set[i][1] = point_data.data[j+1];
		j+=2;
	}

	for ( int i=0; i<(point_data.data.size()/2) ; i++ )
	{
		std::cout << point_data_set[i][0] << ", " << point_data_set[i][1] << std::endl;
	}

	// test1 //
	/*
	target_xy[0][0] = 50.0;
	target_xy[0][1] = 0.0;

	target_xy[1][0] = 50.0;
	target_xy[1][1] = -50.0;

	target_xy[2][0] = 65.0;
	target_xy[2][1] = -100.0;

	target_xy[3][0] = 65.0;
	target_xy[3][1] = -130.0;

	target_xy[4][0] = 100.0;
	target_xy[4][1] = -130.0;

	target_xy[5][0] = 65.0;
	target_xy[5][1] = -130.0;

	target_xy[6][0] = 65.0;
	target_xy[6][1] = -100.0;

	target_xy[7][0] = 50.0;
	target_xy[7][1] = -50.0;

	target_xy[8][0] = 50.0;
	target_xy[8][1] = 0.0;
	*/

	

	///////////////////////////////////
	step_one_rotation_flag = true;
	make_target_yaw_flag = true;

	step_two_rotation_flag = true;
	range_flag = true;
	range_out_flag = true;

	find_direction(point_data_set);
	///////////////////////////////////

	while ( ros::ok() )
	{
		if ( step_two_rotation_flag )
		{
			if ( step_one_rotation_flag )
			{
				// 1. 목표 지점 향하게 만들기 //
				ros::spinOnce();
				move_pub_one.publish(step_one_order);
			}
			else
			{
				// 회전 후 카토그래퍼 안정화를 위해 쉬는 시간 //
				////////////////////////////////////////////////////////
				/*
    				start = std::chrono::system_clock::now();
				sec = std::chrono::system_clock::now() - start;
				while ( sec.count() < 0.2 )
				{
					sec = std::chrono::system_clock::now() - start;
				}
				*/
				////////////////////////////////////////////////////////


				// 2. 목표 지점으로 직진하고 도착하면 멈추기 //
				std::cout <<"target point : "<< target_x <<", " << target_y <<std::endl;
				step_one_done_flag.done_flag = 1;
				step_one_done.publish(step_one_done_flag);
				ros::spinOnce();
				move_pub_two.publish(step_two_order);
				if ( step_two_rotation_flag )
				{
					///////////////////////////////////
					/*
	    				start = std::chrono::system_clock::now();
					sec = std::chrono::system_clock::now() - start;

					while ( sec.count() < 0.2 )
					{
						sec = std::chrono::system_clock::now() - start;
					}
					step_two_order.move_message = 5;
					move_pub_two.publish(step_two_order);
					*/
					///////////////////////////////////

					///////////////////////////////////
					xy_count = xy_count - 1;
					find_direction(point_data_set);
					step_one_rotation_flag = true;
					make_target_yaw_flag = true;
					step_one_done_flag.done_flag = 0;
					step_one_done.publish(step_one_done_flag);
					///////////////////////////////////		
				}
			
			}
		}
		else
		{
			// 어떤경우든 들어오면 일단 정지 //
			step_two_order.move_message = 5;
			move_pub_two.publish(step_two_order);

			///////////////////////////////////
			step_one_rotation_flag = true;
			make_target_yaw_flag = true;

			step_two_rotation_flag = true;
			range_flag = true;
			range_out_flag = true;

			find_direction(point_data_set);
			///////////////////////////////////

			if ( !shutdown_flag )
			{
				for ( int i=0; i<5; i++)
				{
					step_two_order.move_message = 5;
					move_pub_two.publish(step_two_order);
				}
				ros::shutdown();
			}
		}

	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////
cmake_minimum_required(VERSION 2.8.3)
project(project_ros_cpp)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  tf
  message_generation
)
find_package(OpenCV REQUIRED)

 add_message_files(
   FILES
   get_degree.msg
   nano_control.msg
   step_one_flag.msg
 )

 generate_messages(
   DEPENDENCIES
   std_msgs
 )

add_executable(rotaion_and_move src/rotaion_and_move.cpp)
target_link_libraries(rotaion_and_move ${catkin_LIBRARIES})
add_dependencies(rotaion_and_move project_ros_cpp_generate_messages_cpp)

add_executable(clean_map src/clean_map.cpp src/astar.cpp src/pathFinder.cpp)
target_link_libraries(clean_map ${catkin_LIBRARIES} ${OpenCV_LIBS} ${OpenCV_nonfree})
add_dependencies(clean_map project_ros_cpp_generate_messages_cpp)


catkin_package(
  INCLUDE_DIRS include
  LIBRARIES project_ros_cpp
  CATKIN_DEPENDS roscpp rospy std_msgs tf message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

