// 1. waveshare jetbot nano 모터 드라이버 분리 시키기 //
###############################################################################################################################

// 파이썬에 드라이버 설치 //
python3 -m pip install traitlets
python3 -m pip install Adafruit_MotorHAT
// 분리할 소스 //
https://github.com/waveshare/jetbot.git
cd && mkdir temp_jetbot && cd temp_jetbot
git clone https://github.com/waveshare/jetbot.git 안에 들어있는
motor.py 와 robot.py를 활용한다.

cd && mkdir -p my_control_test/src && cd my_control_test/src
catkin_create_pkg my_control std_msgs roscpp rospy tf
cd ~/my_control_test && catkin_make


cd && cd my_control_test/src/my_control/include && vi motor.py
///////////////////////////////////////////////////////////////
import atexit
from Adafruit_MotorHAT import Adafruit_MotorHAT
import traitlets
from traitlets.config.configurable import Configurable


class Motor(Configurable):

    value = traitlets.Float()
    
    # config
    alpha = traitlets.Float(default_value=1.0).tag(config=True)
    beta = traitlets.Float(default_value=0.0).tag(config=True)

    def __init__(self, driver, channel, *args, **kwargs):
        super(Motor, self).__init__(*args, **kwargs)  # initializes traitlets

        self._driver = driver
        self._motor = self._driver.getMotor(channel)
        atexit.register(self._release)
        
    @traitlets.observe('value')
    def _observe_value(self, change):
        self._write_value(change['new'])

    def _write_value(self, value):
        """Sets motor value between [-1, 1]"""
        mapped_value = int(255.0 * (self.alpha * value + self.beta))
        speed = min(max(abs(mapped_value), 0), 255)
        self._motor.setSpeed(speed)
        if mapped_value < 0:
            self._motor.run(Adafruit_MotorHAT.FORWARD)
        else:
            self._motor.run(Adafruit_MotorHAT.BACKWARD)

    def _release(self):
        """Stops motor by releasing control"""
        self._motor.run(Adafruit_MotorHAT.RELEASE)
///////////////////////////////////////////////////////////////


cd && cd my_control_test/src/my_control/include && vi robot.py
///////////////////////////////////////////////////////////////
import time
import traitlets
from traitlets.config.configurable import SingletonConfigurable
from Adafruit_MotorHAT import Adafruit_MotorHAT
from motor import Motor


class Robot(SingletonConfigurable):
    
    left_motor = traitlets.Instance(Motor)
    right_motor = traitlets.Instance(Motor)

    # config
    i2c_bus = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_channel = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    right_motor_channel = traitlets.Integer(default_value=2).tag(config=True)
    right_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    
    def __init__(self, *args, **kwargs):
        super(Robot, self).__init__(*args, **kwargs)
        self.motor_driver = Adafruit_MotorHAT(i2c_bus=self.i2c_bus)
        self.left_motor = Motor(self.motor_driver, channel=self.left_motor_channel, alpha=self.left_motor_alpha)
        self.right_motor = Motor(self.motor_driver, channel=self.right_motor_channel, alpha=self.right_motor_alpha)
        
    def set_motors(self, left_speed, right_speed):
        self.left_motor.value = left_speed
        self.right_motor.value = right_speed
        
    def forward(self, speed=1.0, duration=None):
        self.left_motor.value = speed
        self.right_motor.value = speed

    def backward(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = -speed

    def left(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = speed

    def right(self, speed=1.0):
        self.left_motor.value = speed
        self.right_motor.value = -speed

    def stop(self):
        self.left_motor.value = 0
        self.right_motor.value = 0
///////////////////////////////////////////////////////////////


###############################################################################################################################

























// 2. 예제 만들어보기 //
###############################################################################################################################


cd && cd my_control_test/src/my_control/src && vi move.py
/////////////////////////////////////////////////////////
#!/usr/bin/env python3

from robot import Robot
import time

# 방향 조절
# robot.left
# robot.right
# robot.forward
# robot.backwards

robot = Robot()
robot.left(speed=0.3) # 왼쪽 모터 최대 속도의 30%로 지정
robot.left(0.3) # 위와 같은 표현이다.
time.sleep(0.5) # 0.5초 동안 유지한다.
robot.stop()

# 회전 조절
robot.set_motors(0.3, 0.6) # 좌 회전
time.sleep(1.0)
robot.stop()

# 같은 표현
robot.left_motor.value = 0.3
robot.right_motor.value = 0.6
time.sleep(1.0)
robot.left_motor.value = 0.0
robot.right_motor.value = 0.0
/////////////////////////////////////////////////////////


cd && cd my_control_test/src/my_control/src && chmod +x move.py
cd && cd my_control_test/src/my_control && vi CMakeLists.txt
catkin_package(
#  INCLUDE_DIRS include
   LIBRARIES my_control
   CATKIN_DEPENDS rospy std_msgs message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

cd ~/my_control_test && catkin_make
export PYTHONPATH="${PYTHONPATH}:/home/nvidia/my_control_test/src/my_control/include"


###############################################################################################################################


























// 3. Topic을 Subscribe하여 움직이는 Jetbot nano 드라이버 //
###############################################################################################################################

제어값을 주고받을 .msg 파일 생성
cd && cd Project_ROS_nano/src/project_ros_python/msg && vi nano_control.msg
int32 move_message

토픽명 : ros_move_topic


cd && cd Project_ROS_nano/src/project_ros_python/src && vi ROS_move.py
///////////////////////////////////////////////////////////////
#!/usr/bin/env python3

from robot import Robot
import time
import rospy
from project_ros_python.msg import nano_control

robot = Robot()
robot.set_motors(0.0, 0.0)

left_now = 0.0
right_now = 0.0
left_now_2 = 0.0
right_now_2 = 0.0

max_speed = 0.15
change_speed = 0.025
rotation_speed = 0.15
# 최대 1.0
# 1.0 이상으로 올라가므로 주의한다.

def callback(data):
	global left_now
	global right_now 
	move_value = data.move_message
	rospy.loginfo("I heard from keyboard %d", move_value)
	
	if ( move_value == 1 ):
		# 직진
		robot.set_motors(max_speed, max_speed)
		left_now = max_speed
		right_now = max_speed

	if ( move_value == 2 ):
		# 좌회전
		if (left_now >= max_speed):
			robot.left_motor.value = max_speed - change_speed
			left_now = max_speed - change_speed
		elif (left_now <= 0.0):
			robot.left_motor.value = 0.0
			left_now = 0.0
		else:
			robot.left_motor.value = left_now - change_speed
			left_now = left_now - change_speed

		if (right_now >= max_speed):
			robot.right_motor.value = max_speed
			right_now = max_speed
		elif (right_now <= 0.0):
			robot.right_motor.value = 0.0
			right_now = 0.0
			robot.right_motor.value = right_now + change_speed
			right_now = right_now + change_speed
		else :
			robot.right_motor.value = right_now + change_speed
			right_now = right_now + change_speed

	if ( move_value == 3 ):
		# 우회전
		if (left_now >= max_speed):
			robot.left_motor.value = max_speed
			left_now = max_speed
		elif (left_now <= 0.0):
			robot.left_motor.value = 0.0
			left_now = 0.0
			robot.left_motor.value = left_now + change_speed
			left_now = left_now + change_speed
		else:
			robot.left_motor.value = left_now + change_speed
			left_now = left_now + change_speed

		if (right_now >= max_speed):
			robot.right_motor.value = max_speed - change_speed
			right_now = max_speed - change_speed
		elif (right_now <= 0.0):
			robot.right_motor.value = 0.0
			right_now = 0.0
		else:
			robot.right_motor.value = right_now - change_speed
			right_now = right_now - change_speed

	if ( move_value == 4 ):
		# 후진
		robot.set_motors(-max_speed, -max_speed)
		left_now = -max_speed
		right_now = -max_speed

	if ( move_value == 5 ):
		# 정지
		robot.set_motors(0.0, 0.0)		
		left_now = 0.0
		right_now = 0.0

	if ( move_value == 6 ):
		# 제자리 우회전
		robot.set_motors(rotation_speed, -rotation_speed)		
		left_now = rotation_speed
		right_now = -rotation_speed

	if ( move_value == 7 ):
		# 제자리 좌회전
		robot.set_motors(-rotation_speed, rotation_speed)		
		left_now = -rotation_speed
		right_now = rotation_speed


def wait_listen():
	rospy.init_node('move_subscriber_node', anonymous=True)
	rospy.Subscriber('ros_move_topic', nano_control, callback)
	time.sleep(0.01)
	rospy.spin()

if __name__=='__main__':
	wait_listen()
///////////////////////////////////////////////////////////////
CMakeLists.txt 세팅
cd && cd Project_ROS_nano/src/project_ros_python && vi CMakeLists.txt
 add_message_files(
   FILES
   nano_control.msg
 )
# nano_control.msg 추가

cd && cd Project_ROS_nano/src/project_ros_python/src && chmod +x ROS_move.py
cd && cd Project_ROS_nano && catkin_make

export PYTHONPATH="${PYTHONPATH}:/home/nvidia/Project_ROS_nano/src/project_ros_python/msg"
export PYTHONPATH="${PYTHONPATH}:/home/nvidia/Project_ROS_nano/src/project_ros_python/include"


###############################################################################################################################


























// 4. IMU(MPU6050) 데이터를 Subscribe 하여 움직이는 Jetbot nano 드라이버 //
############################################################################################################################


cd && cd project_black/src/project_ros_python/src && vi imu_degree_control.py
///////////////////////////////////////////////////////////////////////////////
#!/usr/bin/python3

import rospy
import time
from project_ros_python.msg import get_degree
from project_ros_python.msg import nano_control

def callback(data):

	# 0 ~ 360 degree로 전송된다. #
	yaw = data.yaw
	if ( yaw > 180.0 ):
		yaw = yaw-360.0

	rospy.loginfo("I heard dgree yaw %f", yaw)

	if ( yaw > 3.0 ):
		pub.publish(3) # 우회전
	elif ( yaw < -3.0 ):
		pub.publish(2) # 좌회전
	elif ( yaw < 3.0 and yaw > -3.0 ):
		pub.publish(1) # 직진

if __name__=='__main__':
	rospy.init_node('imu_degree_control_node', anonymous=True)
	rospy.Subscriber('project_degree', get_degree, callback)
	pub = rospy.Publisher('ros_move_topic', nano_control, queue_size=1)
	rospy.spin()
///////////////////////////////////////////////////////////////////////////////
cd && cd project_black/src/project_ros_python && vi CMakeLists.txt
 add_message_files(
   FILES
   nano_control.msg
   get_degree.msg
 )
# get_degree.msg 추가 (imu 데이터를 publish할때 사용한 msg파일.)

cd && cd project_black/src/project_ros_python/src && chmod +x imu_degree_control.py
cd && cd project_black && catkin_make


############################################################################################################################


























// 5. 키보드값을 Publish하여 움직이게 만드는 Jetbot nano 드라이버 //
############################################################################################################################

ANSI코드 활용 : https://godoc.org/github.com/tiborvass/uniline/ansi

cd && cd Project_ROS_nano/src/project_ros_python/src && vi keyboard_control.py
///////////////////////////////////////////////////////////////////////////////
#!/usr/bin/python3

import rospy
import time
from project_ros_python.msg import nano_control
import tty, termios, sys
import re

def getchar():

	fd = sys.stdin.fileno()
	old_settings = termios.tcgetattr(fd)
	try:
		tty.setraw(sys.stdin.fileno())
		ch = sys.stdin.read(1)
	finally:
		termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
	return ch
   


def keyboard_order():

	while not rospy.is_shutdown():
		ch = getchar()
		temp_ch = ch
		if (re.findall('[\w]',temp_ch)):
			print ('You pressed : ',temp_ch,'. that is not arrow.')
			if ( temp_ch == 'o'):
				print ('Stop !!!')
				pub.publish(5)
			elif ( temp_ch == 'i'):
				print ('right Spin !!!')
				pub.publish(6)
			elif ( temp_ch == 'u'):
				print ('left Spin !!!')
				pub.publish(7)
		elif (temp_ch == '\x03'):
			print ('Bye Bye, ByeBye ya')
			sys.exit(1)
		else:
			for i in range(2):
				ch = getchar()
				temp_ch = temp_ch + ch
			if (temp_ch == '\x1b[A'):
				print ('You pressed up arrow\n')
				pub.publish(1)
			elif (temp_ch == '\x1b[D'):
				print ('You pressed left arrow\n')
				pub.publish(2)
			elif (temp_ch == '\x1b[C'):
				print ('You pressed right arrow\n')
				pub.publish(3)
			elif (temp_ch == '\x1b[B'):
				print ('You pressed down arrow\n')
				pub.publish(4)

		time.sleep(0.1)

if __name__=='__main__':
	try:
		pub = rospy.Publisher('ros_move_topic', nano_control, queue_size=1)
		rospy.init_node('move_keyboard_node', anonymous=True)
		keyboard_order()

	except rospy.ROSInterruptException:
		pass
///////////////////////////////////////////////////////////////////////////////
cd && cd Project_ROS_nano/src/project_ros_python/src && chmod +x keyboard_control.py
cd && cd Project_ROS_nano && catkin_make

############################################################################################################################


























// 6. imu, TF를 활용하여 원하는 좌표로 이동시키기 //
############################################################################################################################
~~~~
############################################################################################################################
#!/usr/bin/python3

"""
This program handles the communication over I2C
between a Raspberry Pi and a MPU-6050 Gyroscope / Accelerometer combo.
Made by: MrTijn/Tijndagamer
Released under the MIT License
Copyright 2015
"""

"""
https://github.com/Tijndagamer/mpu6050
"""


import rospy
from project_ros_python.msg import get_degree

import smbus
import time
import math
MY_PI = 3.14159265358979323846




class MPU6050:
    # Global Variables
    GRAVITIY_MS2 = 9.80665
    address = None
    bus = smbus.SMBus(0) # 사용되는 i2c 번호

    # Scale Modifiers
    ACCEL_SCALE_MODIFIER_2G = 16384.0
    ACCEL_SCALE_MODIFIER_4G = 8192.0
    ACCEL_SCALE_MODIFIER_8G = 4096.0
    ACCEL_SCALE_MODIFIER_16G = 2048.0

    GYRO_SCALE_MODIFIER_250DEG = 131.0
    GYRO_SCALE_MODIFIER_500DEG = 65.5
    GYRO_SCALE_MODIFIER_1000DEG = 32.8
    GYRO_SCALE_MODIFIER_2000DEG = 16.4

    # Pre-defined ranges
    ACCEL_RANGE_2G = 0x00
    ACCEL_RANGE_4G = 0x08
    ACCEL_RANGE_8G = 0x10
    ACCEL_RANGE_16G = 0x18

    GYRO_RANGE_250DEG = 0x00
    GYRO_RANGE_500DEG = 0x08
    GYRO_RANGE_1000DEG = 0x10
    GYRO_RANGE_2000DEG = 0x18

    # MPU-6050 Registers
    PWR_MGMT_1 = 0x6B
    PWR_MGMT_2 = 0x6C

    SELF_TEST_X = 0x0D
    SELF_TEST_Y = 0x0E
    SELF_TEST_Z = 0x0F
    SELF_TEST_A = 0x10

    ACCEL_XOUT0 = 0x3B
    ACCEL_XOUT1 = 0x3C
    ACCEL_YOUT0 = 0x3D
    ACCEL_YOUT1 = 0x3E
    ACCEL_ZOUT0 = 0x3F
    ACCEL_ZOUT1 = 0x40

    TEMP_OUT0 = 0x41
    TEMP_OUT1 = 0x42

    GYRO_XOUT0 = 0x43
    GYRO_XOUT1 = 0x44

    GYRO_YOUT0 = 0x45
    GYRO_YOUT1 = 0x46

    GYRO_ZOUT0 = 0x47
    GYRO_ZOUT1 = 0x48

    ACCEL_CONFIG = 0x1C
    GYRO_CONFIG = 0x1B

    def __init__(self, address):
        self.address = address

        # Wake up the MPU-6050 since it starts in sleep mode
        self.bus.write_byte_data(self.address, self.PWR_MGMT_1, 0x00)

    # I2C communication methods

    def read_i2c_word(self, register):
        """Read two i2c registers and combine them.
        register -- the first register to read from.
        Returns the combined read results.
        """

        # Read the data from the registers
        high = self.bus.read_byte_data(self.address, register)
        low = self.bus.read_byte_data(self.address, register + 1)

        value = (high << 8) + low
        if (value >= 0x8000):
            return -((65535 - value) + 1)
        else:
            return value

    # MPU-6050 Methods
    def get_temp(self):
        """Reads the temperature from the onboard temperature sensor of the MPU-6050.
        Returns the temperature in degrees Celcius.
        """
        # Get the raw data
        raw_temp = self.read_i2c_word(self.TEMP_OUT0)

        # Get the actual temperature using the formule given in the
        # MPU-6050 Register Map and Descriptions revision 4.2, page 30
        actual_temp = (raw_temp / 340) + 36.53

        # Return the temperature
        return actual_temp

    def set_accel_range(self, accel_range):
        """Sets the range of the accelerometer to range.
        accel_range -- the range to set the accelerometer to. Using a
        pre-defined range is advised.
        """

        # First change it to 0x00 to make sure we write the correct value later
        self.bus.write_byte_data(self.address, self.ACCEL_CONFIG, 0x00)

        # Write the new range to the ACCEL_CONFIG register
        self.bus.write_byte_data(self.address, self.ACCEL_CONFIG, accel_range)

    def read_accel_range(self, raw = False):
        """Reads the range the accelerometer is set to.
        If raw is True, it will return the raw value from the ACCEL_CONFIG
        register
        If raw is False, it will return an integer: -1, 2, 4, 8 or 16. When it
        returns -1 something went wrong.
        """

        # Get the raw value
        raw_data = self.bus.read_byte_data(self.address, self.ACCEL_CONFIG)

        if raw is True:
            return raw_data

        elif raw is False:
            if raw_data == self.ACCEL_RANGE_2G:
                return 2
            elif raw_data == self.ACCEL_RANGE_4G:
                return 4
            elif raw_data == self.ACCEL_RANGE_8G:
                return 8
            elif raw_data == self.ACCEL_RANGE_16G:
                return 16
            else:
                return -1

    def get_accel_data(self, g = False):
        """Gets and returns the X, Y and Z values from the accelerometer.
        If g is True, it will return the data in g
        If g is False, it will return the data in m/s^2
        Returns a dictionary with the measurement results.
        """
        # Read the data from the MPU-6050
        x = self.read_i2c_word(self.ACCEL_XOUT0)
        y = self.read_i2c_word(self.ACCEL_YOUT0)
        z = self.read_i2c_word(self.ACCEL_ZOUT0)

        accel_scale_modifier = None
        accel_range = self.read_accel_range(True)

        if accel_range == self.ACCEL_RANGE_2G:
            accel_scale_modifier = self.ACCEL_SCALE_MODIFIER_2G
        elif accel_range == self.ACCEL_RANGE_4G:
            accel_scale_modifier = self.ACCEL_SCALE_MODIFIER_4G
        elif accel_range == self.ACCEL_RANGE_8G:
            accel_scale_modifier = self.ACCEL_SCALE_MODIFIER_8G
        elif accel_range == self.ACCEL_RANGE_16G:
            accel_scale_modifier = self.ACCEL_SCALE_MODIFIER_16G
        else:
            print("Unkown range - accel_scale_modifier set to self.ACCEL_SCALE_MODIFIER_2G")
            accel_scale_modifier = self.ACCEL_SCALE_MODIFIER_2G

        x = x / accel_scale_modifier
        y = y / accel_scale_modifier
        z = z / accel_scale_modifier

        if g is True:
            return {'x': x, 'y': y, 'z': z}
        elif g is False:
            x = x * self.GRAVITIY_MS2
            y = y * self.GRAVITIY_MS2
            z = z * self.GRAVITIY_MS2
            return {'x': x, 'y': y, 'z': z}

    def set_gyro_range(self, gyro_range):
        """Sets the range of the gyroscope to range.
        gyro_range -- the range to set the gyroscope to. Using a pre-defined
        range is advised.
        """

        # First change it to 0x00 to make sure we write the correct value later
        self.bus.write_byte_data(self.address, self.GYRO_CONFIG, 0x00)

        # Write the new range to the ACCEL_CONFIG register
        self.bus.write_byte_data(self.address, self.GYRO_CONFIG, gyro_range)

    def read_gyro_range(self, raw = False):
        """Reads the range the gyroscope is set to.
        If raw is True, it will return the raw value from the GYRO_CONFIG
        register.
        If raw is False, it will return 250, 500, 1000, 2000 or -1. If the
        returned value is equal to -1 something went wrong.
        """

        # Get the raw value
        raw_data = self.bus.read_byte_data(self.address, self.GYRO_CONFIG)

        if raw is True:
            return raw_data
        elif raw is False:
            if raw_data == self.GYRO_RANGE_250DEG:
                return 250
            elif raw_data == self.GYRO_RANGE_500DEG:
                return 500
            elif raw_data == self.GYRO_RANGE_1000DEG:
                return 1000
            elif raw_data == self.GYRO_RANGE_2000DEG:
                return 2000
            else:
                return -1

    def get_gyro_data(self):
        """Gets and returns the X, Y and Z values from the gyroscope.
        Returns the read values in a dictionary.
        """

        # Read the raw data from the MPU-6050
        x = self.read_i2c_word(self.GYRO_XOUT0)
        y = self.read_i2c_word(self.GYRO_YOUT0)
        z = self.read_i2c_word(self.GYRO_ZOUT0)

        gyro_scale_modifier = None
        gyro_range = self.read_gyro_range(True)

        if gyro_range == self.GYRO_RANGE_250DEG:
            gyro_scale_modifier = self.GYRO_SCALE_MODIFIER_250DEG
        elif gyro_range == self.GYRO_RANGE_500DEG:
            gyro_scale_modifier = self.GYRO_SCALE_MODIFIER_500DEG
        elif gyro_range == self.GYRO_RANGE_1000DEG:
            gyro_scale_modifier = self.GYRO_SCALE_MODIFIER_1000DEG
        elif gyro_range == self.GYRO_RANGE_2000DEG:
            gyro_scale_modifier = self.GYRO_SCALE_MODIFIER_2000DEG
        else:
            print("Unkown range - gyro_scale_modifier set to self.GYRO_SCALE_MODIFIER_250DEG")
            gyro_scale_modifier = self.GYRO_SCALE_MODIFIER_250DEG

        x = x / gyro_scale_modifier
        y = y / gyro_scale_modifier
        z = z / gyro_scale_modifier

        return {'x': x, 'y': y, 'z': z}

    def get_all_data(self):
        """Reads and returns all the available data."""
        temp = get_temp()
        accel = get_accel_data()
        gyro = get_gyro_data()

        return [accel, gyro, temp]


exp_minus = 0.0
def init_imu_yaw():

	print("init start !!!")

	sensor = MPU6050(0x68)
	exp_count = 0
	global exp_minus

	while ( exp_count < 10000 ):

		gyro_data = sensor.get_gyro_data()
		gy_x = gyro_data['x']
		gy_y = gyro_data['y']
		gy_z = gyro_data['z']

		float_gy_z = float(gy_z)
		exp_minus += float_gy_z
		exp_count += 1

	exp_minus = exp_minus/10000.0



def get_from_raw():
	sensor = MPU6050(0x68)
	for_pub = get_degree()

	stamp_time_start = 0.0
	stamp_time_end = 0.0
	dt = 0.0

	global exp_minus
	yaw = 0.0

	sending_time = time.time()

	while not rospy.is_shutdown():
		accel_data = sensor.get_accel_data()
		gyro_data = sensor.get_gyro_data()
		stamp_time_start = stamp_time_end
		stamp_time_end = time.time()

		dt = ( stamp_time_end - stamp_time_start )

		if ( stamp_time_start == 0.0 ):
			dt = 0.0

		ac_x = accel_data['x']
		ac_y = accel_data['y']
		ac_z = accel_data['z']
		gy_x = gyro_data['x']
		gy_y = gyro_data['y']
		gy_z = gyro_data['z']

		roll = math.atan2(ac_y, math.sqrt(ac_x*ac_x + ac_z*ac_z))*180.0/MY_PI
		pitch = math.atan2(ac_x, math.sqrt(ac_y*ac_y + ac_z*ac_z))*180.0/MY_PI
		float_gy_z = float(gy_z) - exp_minus
		yaw = (yaw + float_gy_z*dt)%360

		# degree로 전송한다.
		for_pub.roll = float(roll)
		for_pub.pitch = float(pitch)
		for_pub.yaw = float(yaw)
		for_pub.imu_time_stamp = float(time.clock_gettime(time.CLOCK_MONOTONIC))

		#print("%f" % exp_minus)
		#print("%s" % roll)
		#print("%s" % pitch)
		#print("%s" % yaw)
		#print("%s" % dt)
		#print("")
		if ( (time.time()-sending_time) > 0.2 ):
			pub.publish(for_pub)
			print("i send degree yaw %f" % for_pub.yaw)
			sending_time = time.time()
	

start_value = 0
def start_sign():
	global start_value
	start_value = 1
	

if __name__=='__main__':
	global start_value

	try:
		rospy.init_node('mpu_6050_node', anonymous=True)
		pub = rospy.Publisher('mpu_6050_degree', get_degree, queue_size=1)
		rospy.Subscriber('project_degree', get_degree, start_sign)
		while not rospy.is_shutdown():
			while (start_value)
				init_imu_yaw()
				get_from_raw()

	except rospy.ROSInterruptException:
		pass

