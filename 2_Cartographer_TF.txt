// 1. tf 예제 따라하기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.1 tf_echo를 활용하여 turtle1의 위치 정보와, 각도를 터미널로 추출하기 

cd && mkdir -p test_tf/src && cd test_tf/src && catkin_init_workspace
catkin_create_pkg learning_tf tf roscpp rospy turtlesim // tf, roscpp, rospy, turtlesim의 의존성을 포함시켜 패키지를 생성한다.
cd && cd test_tf && catkin_make && echo "source ~/test_tf/devel/setup.bash" >> ~/.bashrc && source ~/.bashrc
cd ~/test_tf/src/learning_tf/src && vi turtle_tf_broadcaster.cpp
########################################################################################################################
// https://raw.githubusercontent.com/ros/geometry_tutorials/hydro-devel/turtle_tf/src/turtle_tf_broadcaster.cpp // 
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <turtlesim/Pose.h>

std::string turtle_name;

void poseCallback(const turtlesim::PoseConstPtr& msg)
{

  static tf::TransformBroadcaster br;

  tf::Transform transform;
  transform.setOrigin( tf::Vector3(msg->x, msg->y, 0.0) );
  // 2차원 좌표를 msg에서 받고
  // Vector3를 활용해서 z를 0.0으로 추가해서 3차원 좌표계로 setOrigin을 사용해 transform안에 저장한다.

  tf::Quaternion q;
  q.setRPY(0, 0, msg->theta);
  transform.setRotation(q);
  // Quaternion를 활용해 z축에 대한 각도를 q에 담고 setRotation을 사용해 transform안에 저장한다.

  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world", turtle_name));
  // world에 대한 설명
  // https://answers.ros.org/question/12910/about-world-frame/
  // turtle_name을 ros::Time::now()시점에
  // parent frame인 world에
  // transform좌표값에 위치한다고 전달한다.
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "my_tf_broadcaster"); // my_tf_broadcaster라는 노드를 생성한다.

  if (argc != 2){ROS_ERROR("need turtle name as argument"); return -1;};
  turtle_name = argv[1];
  // turtle_tf_broadcaster.cpp이 실행될때 argv[1]을 turtle_name으로 받는다.
  // start_demo.launch파일을 살펴보면 turtle1_tf_broadcaster의 argv[1]은 turtle1이다.

  ros::NodeHandle node;
  ros::Subscriber sub = node.subscribe(turtle_name+"/pose", 10, &poseCallback);

  ros::spin();
  return 0;
};
########################################################################################################################

cd ~/test_tf/src/learning_tf && vi CMakeLists.txt
맨 아래에 아래 내용 추가
add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)
target_link_libraries(turtle_tf_broadcaster ${catkin_LIBRARIES})

cd ~/test_tf && catkin_make
cd ~/test_tf/devel/lib/learning_tf && vi start_demo.launch
########################################################################################################################
  <launch>

    <!-- Turtlesim Node-->
    <node pkg="turtlesim" type="turtlesim_node" name="sim"/>
    <node pkg="turtlesim" type="turtle_teleop_key" name="teleop" output="screen"/>

    <!-- Axes -->
    <param name="scale_linear" value="2" type="double"/>
    <param name="scale_angular" value="2" type="double"/>

    <node pkg="learning_tf" type="turtle_tf_broadcaster"
          args="/turtle1" name="turtle1_tf_broadcaster" />
    <node pkg="learning_tf" type="turtle_tf_broadcaster"
          args="/turtle2" name="turtle2_tf_broadcaster" />

  </launch>
########################################################################################################################
turtlesim_node는 여러가지 cpp를 활용해서 만들어져있다.
https://answers.ros.org/question/214020/where-is-turtlesim_node-inside-the-turtlesim-package/
https://github.com/ros/ros_tutorials/blob/jade-devel/turtlesim/CMakeLists.txt#L25
set(turtlesim_node_SRCS
 src/turtlesim.cpp
 src/turtle.cpp
 src/turtle_frame.cpp)
set(turtlesim_node_HDRS
 include/turtlesim/turtle_frame.h)
turtle_teleop_key는 turtle_teleop_key.cpp로 만들었다.
http://docs.ros.org/melodic/api/turtlesim/html/teleop__turtle__key_8cpp_source.html

roslaunch learning_tf start_demo.launch // 터틀봇이 한개만 표시된다.
rosrun tf tf_echo /world /turtle1 // turtle1의 위치 정보와 각도가 표시된다.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1-2. turtle2가 turtle1을 따라가도록 만들기
cd ~/test_tf/src/learning_tf/src && vi turtle_tf_listener.cpp
########################################################################################################################
// https://raw.githubusercontent.com/ros/geometry_tutorials/groovy-devel/turtle_tf/src/turtle_tf_listener.cpp//
#include <ros/ros.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <turtlesim/Spawn.h>

int main(int argc, char** argv){
  ros::init(argc, argv, "my_tf_listener");

  ros::NodeHandle node; // ROS 시스템과 통신을 위한 노드 핸들 선언

  ros::service::waitForService("spawn");
  ros::ServiceClient add_turtle = node.serviceClient<turtlesim::Spawn>("spawn");
  turtlesim::Spawn srv;
  add_turtle.call(srv);

  ros::Publisher turtle_vel = node.advertise<geometry_msgs::Twist>("turtle2/cmd_vel", 10);
  // 토픽명은 "turtle2/cmd_vel" 이며, Publisher 큐(queue) 사이즈를 10개로 설정한다는 것이다.

  tf::TransformListener listener;
  // TransformListener 오브젝트를 listener라는 이름으로 선언

  ros::Rate rate(10.0);

  while (node.ok())
  {

    tf::StampedTransform transform;

    try
    {
      listener.lookupTransform("/turtle2", "/turtle1", ros::Time(0), transform);
    }
    catch (tf::TransformException &ex)
    {
      ROS_ERROR("%s",ex.what());
      ros::Duration(1.0).sleep();
      continue;
    }

    geometry_msgs::Twist vel_msg;
    vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(),
                                    transform.getOrigin().x());
    vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) +
                                  pow(transform.getOrigin().y(), 2));

    turtle_vel.publish(vel_msg);

    rate.sleep();
  }
  return 0;
};
########################################################################################################################

cd ~/test_tf/src/learning_tf && vi CMakeLists.txt
맨 아랫줄에 아까 추가한 코드에 이어서 내용 추가
add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp) // 원래 있던 내용
add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)
target_link_libraries(turtle_tf_broadcaster ${catkin_LIBRARIES}) // 원래 있던 내용
target_link_libraries(turtle_tf_listener ${catkin_LIBRARIES})

cd ~/test_tf && catkin_make
cd ~/test_tf/devel/lib/learning_tf && vi start_demo.launch
<launch> </launch> 사이에 아래 내용 추가
    <node pkg="learning_tf" type="turtle_tf_listener"
          name="listener" />

roslaunch learning_tf start_demo.launch
아래와 같은 오류가 발생할 수 있다.
    [ERROR] 1253915565.300572000: Frame id /turtle2 does not exist! When trying to transform between /turtle1 and /turtle2.
    [ERROR] 1253915565.401172000: Frame id /turtle2 does not exist! When trying to transform between /turtle1 and /turtle2.
이유는 다음과 같다.
This happens because our listener is trying to compute the transform before messages about turtle 2 have been received
because it takes a little time to spawn in turtlesim and start broadcasting a tf frame. 

rosrun tf tf_echo /world /turtle1 // 위치 정보와 각도가 표시된다.
rosrun tf tf_echo /world /turtle2 // 위치 정보와 각도가 표시된다.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////















// 2. tf_echo를 사용해 좌표 출력 // 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
echo "source ~/carto_with_yd/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc
roslaunch carto_mapper mapper.launch
rosrun ydlidar ydlidar_client

Frame odom exists with parent map.
Frame base_footprint exists with parent odom.
Frame laser_frame exists with parent base_footprint.

cd ~/carto_with_yd/src/learning_tf && vi CMakeLists.txt 를 아래와 같이 수정
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  tf
)

roslaunch carto_mapper mapper.launch
rosrun tf tf_echo /odom /base_footprint
// 전원이 켜진 순간 base_footprint와 odom이 0,0으로 일치한다.
// 움직이면 base_footprint가 이동한다.
// 빨간색이 x, 초록색이 y, 파란색이 z
// 참고자료 http://docs.ros.org/melodic/api/tf/html/c++/tf__echo_8cpp_source.html
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////















// 3. cpp를 만들어 좌표 출력 // 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cd ~/carto_with_yd/src
catkin_create_pkg my_tf_test tf roscpp rospy
vi ~/carto_with_yd/src/my_tf_test/src/my_tf_test.cpp
########################################################################################################################
#include "ros/ros.h"
#include "tf/transform_listener.h"
#define _USE_MATH_DEFINES
#include <cstdio>

int main(int argc, char ** argv)
{
	ros::init(argc, argv, "my_tf_test", ros::init_options::AnonymousName);
	ros::NodeHandle nh;
	ros::Rate loop_rate(1);

	double my_RAD2DEG = 180.0/M_PI;

	// odom은 0,0이고 base_footprint까지의 거리가 부호를 가지며 표시된다.
	// 아래는 직접 필요한 Frame을 넣어준다.
	std::string start = std::string("/odom"); 
	std::string move = std::string("/base_footprint");

	// 첫번째 전송이 완료될때까지 1초동안 기다립니다.
	tf::TransformListener tfl;
	tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));

	while(nh.ok())
	{
		tf::StampedTransform my_test_transform;
		tfl.lookupTransform(start, move, ros::Time(), my_test_transform);

		double yaw, pitch, roll;
		my_test_transform.getBasis().getRPY(roll, pitch, yaw);
		tf::Quaternion q = my_test_transform.getRotation();
		tf::Vector3 Coordinate_3D = my_test_transform.getOrigin();

		std::cout<<"시작 점으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
		std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
		std::cout<<"축 회전 각 [degree] (roll, pitch, yaw)"<<std::endl;
		std::cout<<"	("<<roll*my_RAD2DEG<<", "<<pitch*my_RAD2DEG<<", "<<yaw*my_RAD2DEG<<")"<< std::endl;
		loop_rate.sleep();
	}

	return 0;
}
########################################################################################################################
cd ~/carto_with_yd/src/my_tf_test && vi CMakeLists.txt
맨아래에 아래 코드 추가
add_executable(my_tf_test src/my_tf_test.cpp)
target_link_libraries(my_tf_test ${catkin_LIBRARIES})

cd ~/carto_with_yd && catkin_make
roslaunch carto_mapper mapper.launch
rosrun my_tf_test my_tf_test
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





















// 4. Laserscan 값으로 맵 그리기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vi ~/carto_with_yd/src/my_tf_test/src/my_tf_test_map.cpp
########################################################################################################################
#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#include <math.h>
#include <opencv2/opencv.hpp>
#include "tf/transform_listener.h"
#define _USE_MATH_DEFINES
#include <cstdio>
#define RAD2DEG(x) ((x)*180./M_PI)

using namespace cv;

// 초기 맵 세팅
// 중심 (0,0) (가로10, 세로10) (최대측정거리 10)
// enlarge : 확대 시킨다. ( 30배 )
// padding : 확대 후 매트릭스의 여백 설정 ( 10 입력하면 상하좌우 10씩 늘어난다. )
// 1픽셀 = 1m, 30배 확대햇으면 30픽셀 = 1m 이다.

#define enlarge 30
#define padding 0
Mat my_map(20*enlarge+(padding*2), 20*enlarge+(padding*2), CV_64FC3, Scalar(0));
Mat re_create_map(20*enlarge+(padding*2), 20*enlarge+(padding*2), CV_64FC3, Scalar(0));
Mat temp_my_map;


// 초기 좌표계
Point2d my_center(my_map.size().width/2, my_map.size().height/2);
Point2d my_axis_x(my_map.size().width/8,0);
Point2d my_axis_y(0,my_map.size().height/8);
Point2d my_axis_x_rotation, my_axis_y_rotation;

// 발견한 거리
Point2d detection;

int re_map=0; // 맵을 갱신시키기 위한 카운트
int re_axis=0; // 좌표계 갱신시키기 위한 카운트

// 포인트 회전을 위한 함수 
Point2d point_rotation(Point2d a, double b)
{
	Point2d temp_a(a.x,a.y);

	temp_a.x = a.x*cos(b) - a.y*sin(b);
	temp_a.y = a.x*sin(b) + a.y*cos(b);

	std::cout<<temp_a.x<<" "<<temp_a.y<< std::endl;
	return temp_a;
}


void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan)
{
// 좌표 획득 부분 //

	std::string start = std::string("/odom"); 
	std::string move = std::string("/base_footprint");

	tf::TransformListener tfl;
	tfl.waitForTransform(start, move, ros::Time(), ros::Duration(1.0));

	tf::StampedTransform for_get_coordinate;
	tfl.lookupTransform(start, move, ros::Time(), for_get_coordinate);

	double roll, pitch, yaw;
	for_get_coordinate.getBasis().getRPY(roll, pitch, yaw);
	tf::Quaternion q = for_get_coordinate.getRotation();
	tf::Vector3 Coordinate_3D = for_get_coordinate.getOrigin();

	//std::cout<<"시작 점으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
	//std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
	//std::cout<<"축 회전 각 [degree] (roll, pitch, yaw)"<<std::endl;
	
	std::cout<<"	("<<roll*180./M_PI<<", "<<pitch*180./M_PI<<", "<<yaw*180./M_PI<<")"<< std::endl;
	std::cout<<roll<<" "<<pitch<<" "<<yaw<<std::endl;

	// 맵 데이터 획득은 50번 마다 갱신 //
	if(re_map<50)
	{
	}
	else
	{
		my_map = re_create_map.clone();
		re_map = 0;
	}


	// 맵 데이터 획득부분//
	int count = scan->scan_time / scan->time_increment;

	double my_array[1000][2];
	// count값의 최대치를 대략적으로 찍어보고 1000개에서 숫자를 조정한다.
	// 매번 -180에서 180사이에 if를 거쳤을때 저장될 값이 변하므로 넉넉하게 잡는다.

	int m_a_count = 0;
	for(int i = 0; i < count; i++)
	{
		float degree = RAD2DEG(scan->angle_min + scan->angle_increment * i);
		if(degree > -180 && degree< 180)
		{
			if(isinf(scan->ranges[i])||scan->ranges[i]<0.1||scan->ranges[i]>10) // 0.1 이하거나 10이상이면 버린다.
			{
			}
			else
			{
				//printf("angle, distance : [%.3f, %.3f]\n", degree, scan->ranges[i]);
				//std::cout<<roll*180./M_PI<<", "<<pitch*180./M_PI<<", "<<yaw*180./M_PI<< std::endl;
				my_array[m_a_count][0] = degree;
				my_array[m_a_count][1] = scan->ranges[i];

				detection.x =  my_center.x + my_array[i][1]*cos(my_array[i][0]*M_PI/180.0)*enlarge;
				detection.y =  my_center.y + -my_array[i][1]*sin(my_array[i][0]*M_PI/180.0)*enlarge;

				circle(my_map, detection, 3, Scalar(0), 1);
				// my_map의 detection위치에 반지름 3의 검은색 원

				line(my_map, my_center, detection, Scalar(255,255,255), 2);
				// my_map의 my_center부터 detection까지 흰색으로 굵기 2 라인
				
				++m_a_count; 
			}
		}
	}

	temp_my_map = my_map.clone();

	// 좌표축은 5번 마다 갱신 //
	if(re_axis<5)
	{
		line(temp_my_map, my_center, my_axis_x_rotation, Scalar(0, 0, 255), 2); // x 빨간색
		line(temp_my_map, my_center, my_axis_y_rotation, Scalar(0, 255, 0), 2); // y 초록색
	}
	else
	{
		my_axis_x_rotation = point_rotation(my_axis_x,-yaw)+my_center;
		my_axis_y_rotation = point_rotation(my_axis_y,yaw);
		my_axis_y_rotation.y = -my_axis_y_rotation.y;
		my_axis_y_rotation = my_axis_y_rotation+my_center;
		line(temp_my_map, my_center, my_axis_x_rotation, Scalar(0, 0, 255), 2); // x 빨간색
		line(temp_my_map, my_center, my_axis_y_rotation, Scalar(0, 255, 0), 2); // y 초록색
		re_axis = 0;
	}
	moveWindow("my_map_window", 100, 100); // 모니터의 좌측 상단이 원점이다. (+x -y)
	namedWindow("my_map_window", WINDOW_AUTOSIZE); // WINDOW_AUTOSIZE = 할당된 행렬에 딱 맞게 크기를 생성함, 크기조절 불가
	imshow("my_map_window", temp_my_map);
	waitKey(1);

	++re_map;
	++re_axis;
}

int main(int argc, char **argv)
{
	// 초기 좌표축 x,y 설정 //
	my_axis_x_rotation = my_axis_x + my_center;
	my_axis_y_rotation = my_axis_y;
	my_axis_y_rotation.y = -my_axis_y_rotation.y;
	my_axis_y_rotation = my_axis_y_rotation + my_center;

	ros::init(argc, argv, "ydlidar_client");
	ros::NodeHandle n;
	ros::Subscriber sub = n.subscribe<sensor_msgs::LaserScan>("/scan", 1000, scanCallback);
	ros::spin();
	return 0;
}
########################################################################################################################
cd ~/carto_with_yd/src/my_tf_test && vi CMakeLists.txt
아래 내용으로 수정한다.

cmake_minimum_required(VERSION 2.8.3)
project(my_tf_test)

find_package(OpenCV REQUIRED)
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  tf
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES my_tf_test
#  CATKIN_DEPENDS roscpp rospy tf
#  DEPENDS system_lib
)

include_directories(
# include
  ${catkin_INCLUDE_DIRS}
)


add_executable(my_tf_test src/my_tf_test.cpp)
target_link_libraries(my_tf_test ${catkin_LIBRARIES})
add_executable(my_tf_test_map src/my_tf_test_map.cpp)
target_link_libraries(my_tf_test_map
   ${catkin_LIBRARIES}
   ${OpenCV_LIBS}
 )


cd ~/carto_with_yd && catkin_make
roslaunch carto_mapper mapper.launch
rosrun my_tf_test my_tf_test_map
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
















##########################################################################################################################
############################################# 4. 맵(회전) ###############################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#define RAD2DEG(x) ((x)*180./M_PI)
#include <math.h>
#include <opencv2/opencv.hpp>
#include "hough.hpp"

using namespace cv;

// ?? ??? ??? ???.
#define enlarge 30

Mat my_map(20*enlarge, 20*enlarge, CV_8UC1, Scalar(0));
int re_map=0;

void max_object(Mat img, Rect &rect ) 
{
	vector<vector<Point>> contours;
	findContours(img.clone(), contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);	// ¿Ü°û\u0152± °ËÃâ
	
	int max_area = 0 ;
	for (int i = 0; i < (int)contours.size(); i++)	// °¡Àå Å« ¿µ¿ª °¡Á®¿À±â
	{
		Rect r = boundingRect(contours[i]);			// ¿Ü°û\u0152± ¿µ¿ª Æ÷ÇÔ »ç°¢Çü
		if (max_area < r.area()) {
			max_area = r.area();
			rect = r;
		}
	}
	rect = rect - Point(10, 10) + Size(20, 20);
}

void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan)
{
	int count = scan->scan_time / scan->time_increment;
	double my_array[1000][2]; // count?? ???? ????? ???? 1000??? ??? ????.

	int m_a_count = 0;
	for(int i = 0; i < count; i++)
	{
		float degree = RAD2DEG(scan->angle_min + scan->angle_increment * i);
		if(degree > -180 && degree< 180)
		{
			if(isinf(scan->ranges[i])||scan->ranges[i]<0.1||scan->ranges[i]>10)
			{
			}
			else
			{
				printf("angle, distance : [%.3f, %.3f]\n", degree, scan->ranges[i]);
				my_array[m_a_count][0] = degree;
				my_array[m_a_count][1] = scan->ranges[i];
				++m_a_count; 
			}
		}
	}

	if(re_map<50)
	{
	}
	else
	{
		std::cout<< "hello" << std::endl;
		Mat re_create_map(20*enlarge, 20*enlarge, CV_8UC1, Scalar(0));
		std::cout<< "hello2" << std::endl;
		my_map = re_create_map;
		std::cout<< "hello3" << std::endl;
		re_map = 0;
	}
	
	Point2d my_center(my_map.size().width/2, my_map.size().height/2); // Tag1 //
	Point2d detection;
	for(int i = 0; i < m_a_count; i++)
	{
		std::cout<<"angle : "<<my_array[i][0]<<", distance : "<< my_array[i][1] << std::endl;
		detection.x =  my_center.x + my_array[i][1]*cos(my_array[i][0]*CV_PI/180.0)*enlarge*5;
		detection.y =  my_center.y + -my_array[i][1]*sin(my_array[i][0]*CV_PI/180.0)*enlarge*5;
		circle(my_map, detection, 3, Scalar(0), 1);
		line(my_map, my_center, detection, Scalar(255), 3);
	}
	++re_map;
	moveWindow("my_map_window", 100, 100); // (+x -y)
	namedWindow("my_map_window", WINDOW_AUTOSIZE);
	imshow("my_map_window", my_map);


	Rect rect;
	Mat gray, canny, morph, th_gray, canny_line, dst;
	double rho = 1, theta = CV_PI / 180;	
	vector<Vec2f> lines;	

	Mat image = my_map;
	CV_Assert(image.data);

	//cvtColor(image, gray, CV_BGR2GRAY);
	threshold(image, th_gray, 240, 255, THRESH_BINARY);
	erode(th_gray, morph, Mat(), Point(-1, -1), 2);

	max_object(morph, rect);
	rectangle(morph, rect, Scalar(100), 2);	

	Canny(th_gray(rect), canny, 40, 100);
	houghLines(canny, lines, rho, theta, 50);
	draw_houghLines(canny, canny_line, lines, 1);

	double angle = (CV_PI - lines[0][1]) * 180 / CV_PI  ;
	Point  center = image.size() / 2;
	Mat rot_map = getRotationMatrix2D(center, -angle, 1);
	
	warpAffine(image, dst, rot_map, image.size(), INTER_LINEAR);
	imshow("morph", morph);
	imshow("image", image);
	imshow("line", canny_line);
	imshow("dst", dst);
	waitKey(1);
	std::cout<< count << std::endl;
}

int main(int argc, char **argv)
{
	ros::init(argc, argv, "ydlidar_client");
	ros::NodeHandle n;
	ros::Subscriber sub = n.subscribe<sensor_msgs::LaserScan>("/scan", 1000, scanCallback);
	moveWindow("morph", 500, 100); 
	moveWindow("image", 500, 100); 
	moveWindow("line", 500, 100); 
	moveWindow("dst", 500, 100); 
	ros::spin();
	return 0;
}










https://github.com/googlecartographer/cartographer_ros/issues/1032


참고
http://wiki.ros.org/rosserial_arduino/Tutorials/Time%20and%20TF
  26   t.header.frame_id = odom;
  27   t.child_frame_id = base_link;
