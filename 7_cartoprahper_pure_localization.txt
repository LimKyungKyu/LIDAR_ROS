1. carto_mapper mapper.launch 실행

2. 터미널에서 rosservice call /finish_trajectory 0 입력
-맵 기록을 중단한다.

3. 터미널에서 rosservice call /write_state /home/nvidia/원하는이름.bag.pbstream

4. cartographer의 x2.lua를 복사하고 아래 내용을 추가한다.
test.lua
TRAJECTORY_BUILDER.pure_localization = true
POSE_GRAPH.optimize_every_n_nodes = 20
 
5. carto_mapper의 mapper.launch를 복사하고 이름을 바꿔서 아래 내용을 추가한다.
test_local.launch
-configuration_basename test.lua (lua파일을 4번에서 만든 이름으로 지정한다.)
-load_state_filename $(arg load_state_filename)

6. 터미널에서 carto_mapper test_local.launch load_state_filename:=${HOME}/저장된것.bag.pbstream





// 청소를 위한 map 만들기 //
cd && cd project_black/src/project_ros_cpp/src && vi clean_map.cpp
############################################################################################################################
#include <ros/ros.h>
#include <nav_msgs/MapMetaData.h>
#include <nav_msgs/OccupancyGrid.h>
#include "std_msgs/Header.h"
#include "nav_msgs/MapMetaData.h"
#include <vector>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <chrono>
#include <cstdio>
#include "project_ros_cpp/nano_control.h"

#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <opencv2/imgproc/imgproc.hpp>

#define _USE_MATH_DEFINES

#define map_square_padding 10

int add_padding(cv::Mat resizing_mat)
{
	if ( resizing_mat.rows >= resizing_mat.cols )
	{
		return int(resizing_mat.rows)+map_square_padding*2;
	}
	else
	{
		return int(resizing_mat.cols)+map_square_padding*2;
	}
}

void mapCallback(const nav_msgs::OccupancyGrid::ConstPtr& msg){


	std_msgs::Header header = msg->header;
	nav_msgs::MapMetaData info = msg->info;

	/*
	std::cout<<"Map 으로 부터 현재 위치 [metric] (x, y, z)"<<std::endl;
	std::cout<<"	("<<Coordinate_3D.getX()<<", "<<Coordinate_3D.getY()<<", "<<Coordinate_3D.getZ()<<")"<<std::endl;
	std::cout<<"축 회전 각 [degree] (roll, pitch, yaw)"<<std::endl;
	std::cout<<"	("<<roll*my_RAD2DEG<<", "<<pitch*my_RAD2DEG<<", "<<yaw*my_RAD2DEG<<")"<< std::endl;
	*/

	std::vector<signed char> data = msg->data;

	cv::Mat meta_data = cv::Mat(data).reshape(1,info.height);
	cv::Mat meta_resize;
	meta_data.convertTo(meta_resize,CV_8UC1);
	int mat_size = add_padding(meta_resize);
	cv::Mat original(mat_size, mat_size, CV_8UC1, cv::Scalar(0));
	for (int i=0; i<meta_resize.rows; i++)
		for (int j=0; j<meta_resize.cols; j++)
			original.at<unsigned char>(i+map_square_padding,j+map_square_padding) = meta_resize.at<unsigned char>(i,j);

	cv::Mat wall_padding_mat(original.size(),original.type(),cv::Scalar(0));
	int pdding_size = 10; // 10이면 벽의 상하좌우로 5px씩, 10cm
	for (int i=0; i<original.rows; i++)
		for (int j=0; j<original.cols; j++)
			if ( int(original.at<unsigned char>(i,j)) > 50 )
				for ( int k=0; k<=pdding_size; k++ )
					for ( int l=0; l<=pdding_size; l++ )
					{
						//std::cout << "here 2" << std::endl;
						if ( (i+k-5)<0 || (i+k-5)>=original.rows || (j+l-5)<0 || (j+l-5)>=original.cols ) {}
						else { wall_padding_mat.at<unsigned char>( (i+k-5), (j+l-5) )=255; }
					}



	cv::Mat canny_temp;
	cv::Canny(wall_padding_mat, canny_temp, 100, 100*2, 3);
	std::vector<std::vector<cv::Point>> contours;
	std::vector<cv::Vec4i> hierarchy;
	cv::findContours(canny_temp, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);

	/*
	cv::Mat show_contour;
	cv::cvtColor(wall_padding_mat, show_contour, cv::COLOR_GRAY2BGR);
	for ( int i=0; i<int(contours.size()); i++)
	{
		cv::drawContours(show_contour, contours, i, cv::Scalar(255,0,0),2,8,hierarchy,0,cv::Point());
	}
	std::cout << contours[0] << std::endl;
	std::cout << contours[0][0] << std::endl;
	std::cout << contours[0][0].x << std::endl;
	std::cout << contours[0][0].y << std::endl;
	std::cout << int(contours.size()) << std::endl;
	std::cout << int(contours[0].size()) << std::endl;
	cv::imshow("show_contour", show_contour);
	*/

	cv::Mat back_ground_white(wall_padding_mat.size(), wall_padding_mat.type(), cv::Scalar(0));
	cv::fillPoly(back_ground_white, contours, cv::Scalar(255));

	for (int i=0; i<back_ground_white.rows; i++)
		for (int j=0; j<back_ground_white.cols; j++)
			if ( back_ground_white.at<unsigned char>(i,j) == 0 )
				back_ground_white.at<unsigned char>(i,j) = 255;
			else
				back_ground_white.at<unsigned char>(i,j) = 0;

	wall_padding_mat = wall_padding_mat + back_ground_white;

	for ( int i=0; i<int(contours.size()); i++)
	{
		cv::drawContours(wall_padding_mat, contours, i, cv::Scalar(255),2,8,hierarchy,0,cv::Point());
	}

	ROS_INFO("Got map %d %d", info.width, info.height);
	ROS_INFO("Map Origin x %f", info.origin.position.x);
	ROS_INFO("Map Origin y %f", info.origin.position.y);

	int map_origin_x = -info.origin.position.x*100.0/2.0 + map_square_padding ;
	int map_origin_y = -info.origin.position.y*100.0/2.0 + map_square_padding ;

	std::cout << "x : " << map_origin_x <<std::endl;
	std::cout << "y : " << map_origin_y <<std::endl;

	cv::Mat color_map;
	cv::Mat in[] = {wall_padding_mat, wall_padding_mat, wall_padding_mat};
	merge(in, 3, color_map);
	cv::circle( color_map, cv::Point(map_origin_x, map_origin_y), 2, cv::Scalar(255,0,0), -1);

	cv::flip(color_map, color_map, 0);

	cv::imshow("meta_data", meta_data);
	cv::imshow("original", original);
	cv::imshow("back_ground_white", back_ground_white);
	cv::imshow("wall_padding_mat", wall_padding_mat);
	cv::imshow("color_map", color_map);
	cv::waitKey(100);


}

int main(int argc, char **argv){
	ros::init(argc, argv, "map_reader");
	ros::NodeHandle n;
	ros::Subscriber map_sub = n.subscribe("map",2000,mapCallback);
	ros::spin();

	return 0;

}
############################################################################################################################

cd && cd project_black/src/project_ros_cpp && vi CMakeLists.txt
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  tf
  message_generation
)
find_package(OpenCV REQUIRED)

 add_message_files(
   FILES
   get_degree.msg
   nano_control.msg
   step_one_flag.msg
 )

 generate_messages(
   DEPENDENCIES
   std_msgs
 )

add_executable(rotaion_and_move src/rotaion_and_move.cpp)
target_link_libraries(rotaion_and_move ${catkin_LIBRARIES})
add_dependencies(rotaion_and_move project_ros_cpp_generate_messages_cpp)

add_executable(clean_map src/clean_map.cpp)
target_link_libraries(clean_map ${catkin_LIBRARIES} ${OpenCV_LIBS} ${OpenCV_nonfree})
add_dependencies(clean_map project_ros_cpp_generate_messages_cpp)


catkin_package(
#  INCLUDE_DIRS include
  LIBRARIES project_ros_cpp
  CATKIN_DEPENDS roscpp rospy std_msgs tf message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

