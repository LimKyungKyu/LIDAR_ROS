// 1. waveshare 젯봇에서 모터 드라이버 분리 시키기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
https://github.com/waveshare/jetbot.git

cd && mkdir temp_jetbot && cd temp_jetbot
git clone https://github.com/waveshare/jetbot.git

cd && mkdir -p my_control_test/src && cd my_control_test/src
catkin_create_pkg my_control std_msgs roscpp rospy tf
cd ~/my_control_test && catkin_make

cd && cd my_control_test/src/my_control/include && vi motor.py
###############################################################################################################################
import atexit
from Adafruit_MotorHAT import Adafruit_MotorHAT
import traitlets
from traitlets.config.configurable import Configurable


class Motor(Configurable):

    value = traitlets.Float()
    
    # config
    alpha = traitlets.Float(default_value=1.0).tag(config=True)
    beta = traitlets.Float(default_value=0.0).tag(config=True)

    def __init__(self, driver, channel, *args, **kwargs):
        super(Motor, self).__init__(*args, **kwargs)  # initializes traitlets

        self._driver = driver
        self._motor = self._driver.getMotor(channel)
        atexit.register(self._release)
        
    @traitlets.observe('value')
    def _observe_value(self, change):
        self._write_value(change['new'])

    def _write_value(self, value):
        """Sets motor value between [-1, 1]"""
        mapped_value = int(255.0 * (self.alpha * value + self.beta))
        speed = min(max(abs(mapped_value), 0), 255)
        self._motor.setSpeed(speed)
        if mapped_value < 0:
            self._motor.run(Adafruit_MotorHAT.FORWARD)
        else:
            self._motor.run(Adafruit_MotorHAT.BACKWARD)

    def _release(self):
        """Stops motor by releasing control"""
        self._motor.run(Adafruit_MotorHAT.RELEASE)

###############################################################################################################################


cd && cd my_control_test/src/my_control/include && vi robot.py
###############################################################################################################################
import time
import traitlets
from traitlets.config.configurable import SingletonConfigurable
from Adafruit_MotorHAT import Adafruit_MotorHAT
from motor import Motor


class Robot(SingletonConfigurable):
    
    left_motor = traitlets.Instance(Motor)
    right_motor = traitlets.Instance(Motor)

    # config
    i2c_bus = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_channel = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    right_motor_channel = traitlets.Integer(default_value=2).tag(config=True)
    right_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    
    def __init__(self, *args, **kwargs):
        super(Robot, self).__init__(*args, **kwargs)
        self.motor_driver = Adafruit_MotorHAT(i2c_bus=self.i2c_bus)
        self.left_motor = Motor(self.motor_driver, channel=self.left_motor_channel, alpha=self.left_motor_alpha)
        self.right_motor = Motor(self.motor_driver, channel=self.right_motor_channel, alpha=self.right_motor_alpha)
        
    def set_motors(self, left_speed, right_speed):
        self.left_motor.value = left_speed
        self.right_motor.value = right_speed
        
    def forward(self, speed=1.0, duration=None):
        self.left_motor.value = speed
        self.right_motor.value = speed

    def backward(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = -speed

    def left(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = speed

    def right(self, speed=1.0):
        self.left_motor.value = speed
        self.right_motor.value = -speed

    def stop(self):
        self.left_motor.value = 0
        self.right_motor.value = 0

###############################################################################################################################

cd && cd my_control_test/src/my_control/src && vi move.py
###############################################################################################################################
#!/usr/bin/env python3

from robot import Robot
import time # time.sleep(0.5) 을 사용하기 위한 모듈 time을 import한다.

# 방향 조절
# robot.left
# robot.right
# robot.forward
# robot.backwards

robot = Robot()
robot.left(speed=0.3) # 왼쪽 모터 최대 속도의 30%로 지정
robot.left(0.3) # 위와 같은 표현이다.
time.sleep(0.5) # 0.5초 동안 유지한다.
robot.stop()


# 회전 조절
robot.set_motors(0.3, 0.6) # 좌 회전
time.sleep(1.0)
robot.stop()

# 같은 표현
robot.left_motor.value = 0.3
robot.right_motor.value = 0.6
time.sleep(1.0)
robot.left_motor.value = 0.0
robot.right_motor.value = 0.0
###############################################################################################################################

cd && cd my_control_test/src/my_control/src && chmod +x move.py
cd && cd my_control_test/src/my_control && vi CMakeLists.txt
catkin_package(
#  INCLUDE_DIRS include
   LIBRARIES my_control
   CATKIN_DEPENDS rospy std_msgs message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

cd ~/my_control_test && catkin_make
export PYTHONPATH="${PYTHONPATH}:/home/nvidia/my_control_test/src/my_control/include"
echo "source ~/my_control_test/devel/setup.bash" >> ~/.bashrc && source ~/.bashrc
	오류시 sudo apt-get install python3-pip
	python3 -m pip install traitlets
	python3 -m pip install Adafruit_MotorHAT
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




















// 2. 키보드 입력으로 작동시키기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cd && vi test.py
python3 -m pip install keyboard
###############################################################################################################################
#!/usr/bin/python3

import time
import keyboard
while True:
	try:
		if keyboard.is_pressed('q'):
			print('You Pressed q Key!')
			time.sleep(0.01)
		else: 
			pass 
	except: 
		break
###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





// 2-1. 방향키 값 캐치 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cd && vi test.py
python3 -m pip install keyboard
###############################################################################################################################
#!/usr/bin/python3

import time
import keyboard
while True:
	try:
		if keyboard.is_pressed("up arrow"):
			print('You Pressed Up Key!')
			robot.set_motors(0.3, 0.6)
			time.sleep(1.0)
			robot.stop()
		else: 
			pass 
	except: 
		break
###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






// 2-2. 방향키 값 캐치 (저수준 생성) //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
###############################################################################################################################
#!/usr/bin/python3

import os
import sys    
import termios
import fcntl
import time

def getch():
  fd = sys.stdin.fileno()

  oldterm = termios.tcgetattr(fd)
  newattr = termios.tcgetattr(fd)
  newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
  termios.tcsetattr(fd, termios.TCSANOW, newattr)

  oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
  fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

  try:        
    while 1:            
      try:
        c = sys.stdin.read(3)
        break
      except IOError: pass
  finally:
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
  return c

while True:
	hello = getch()
	if hello == 'i':
		print("123")
	elif hello == '\x1b[A':
		print("ooo")
	time.sleep(1)
###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







// 2-3. 결과적으로 키보드 입력으로 사용할것 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
###############################################################################################################################
#!/usr/bin/python3

import tty, termios, sys
import re

# ANSI : https://godoc.org/github.com/tiborvass/uniline/ansi

def getchar():

	fd = sys.stdin.fileno()
	old_settings = termios.tcgetattr(fd)
	try:
		tty.setraw(sys.stdin.fileno())
		ch = sys.stdin.read(1)
	finally:
		termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
	return ch
   
while True:
	ch = getchar()
	temp_ch = ch
	if (re.findall('[\w]',temp_ch)):
		print ('You pressed keyboard, not arrow', temp_ch)
	elif (temp_ch == '\x03'):
		print ('Bye Bye, ByeBye ya')
		sys.exit(1)
	else:
		for i in range(2):
			ch = getchar()
			temp_ch = temp_ch + ch
		if (temp_ch == '\x1b[A'):
			print ('You pressed up arrow\n')

###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////










































// KEYES-345 이용해서 가속도로 각도 구하기 //
// 직접 계산
http://students.iitk.ac.in/roboclub/2017/12/21/Beginners-Guide-to-IMU.html
roll, pitch를 정확하게 계산한 사이트

http://wizmoz.blogspot.com/2013/01/simple-accelerometer-data-conversion-to.html?_sm_au_=iVVrPJjs44Sjbntq
그냥 참고용

// yaw값을 구하지 못하는 이유
http://mythinkg.blogspot.com/2014/03/mpu-6050-rollpitch.html

// 파이썬 코드 (성공)
https://github.com/Seeed-Studio/Grove_Starter_Kit_for_BBG/blob/master/grove_accelerometer_16g/adxl345.py

// 필요 패키지
sudo apt-get install git build-essential python3-dev python-dev
git clone https://github.com/adafruit/Adafruit_Python_ADXL345.git
cd Adafruit_Python_ADXL345
sudo python3 setup.py install
python3 -m pip install adafruit-adxl345
python3 -m pip install smbus

https://pinkwink.kr/1072 따라해보기
https://answers.ros.org/question/246256/how-to-visualize-imu-data-in-rviz/ 살펴보기

###############################################################################################################################
#!/usr/bin/python3

import smbus
import time
import math

bus = smbus.SMBus(1)

# ADXL345 device address
ADXL345_DEVICE = 0x53

# ADXL345 constants
EARTH_GRAVITY_MS2   = 9.80665
SCALE_MULTIPLIER    = 0.004

DATA_FORMAT         = 0x31
BW_RATE             = 0x2C
POWER_CTL           = 0x2D

BW_RATE_1600HZ      = 0x0F
BW_RATE_800HZ       = 0x0E
BW_RATE_400HZ       = 0x0D
BW_RATE_200HZ       = 0x0C
BW_RATE_100HZ       = 0x0B
BW_RATE_50HZ        = 0x0A
BW_RATE_25HZ        = 0x09

RANGE_2G            = 0x00
RANGE_4G            = 0x01
RANGE_8G            = 0x02
RANGE_16G           = 0x03

MEASURE             = 0x08
AXES_DATA           = 0x32

class ADXL345:

	address = None

	def __init__(self, address = ADXL345_DEVICE):        
		self.address = address
		self.setBandwidthRate(BW_RATE_100HZ)
		self.setRange(RANGE_2G)
		self.enableMeasurement()

	def enableMeasurement(self):
		bus.write_byte_data(self.address, POWER_CTL, MEASURE)

	def setBandwidthRate(self, rate_flag):
		bus.write_byte_data(self.address, BW_RATE, rate_flag)

    # set the measurement range for 10-bit readings
	def setRange(self, range_flag):
		value = bus.read_byte_data(self.address, DATA_FORMAT)

		value &= ~0x0F;
		value |= range_flag;  
		value |= 0x08;

		bus.write_byte_data(self.address, DATA_FORMAT, value)
    
    # returns the current reading from the sensor for each axis
    #
    # parameter gforce:
    #    False (default): result is returned in m/s^2
    #    True           : result is returned in gs
	def getAxes(self, gforce = False):
		bytes = bus.read_i2c_block_data(self.address, AXES_DATA, 6)
		
		x = bytes[0] | (bytes[1] << 8)
		if(x & (1 << 16 - 1)):
			x = x - (1<<16)

		y = bytes[2] | (bytes[3] << 8)
		if(y & (1 << 16 - 1)):
			y = y - (1<<16)

		z = bytes[4] | (bytes[5] << 8)
		if(z & (1 << 16 - 1)):
			z = z - (1<<16)

		x = x * SCALE_MULTIPLIER 
		y = y * SCALE_MULTIPLIER
		z = z * SCALE_MULTIPLIER

		if gforce == False:
			x = x * EARTH_GRAVITY_MS2
			y = y * EARTH_GRAVITY_MS2
			z = z * EARTH_GRAVITY_MS2

		x = round(x, 4)
		y = round(y, 4)
		z = round(z, 4)

		return {"x": x, "y": y, "z": z}

if __name__ == "__main__":
	# if run directly we'll just create an instance of the class and output 
	# the current readings
	adxl345 = ADXL345()
	M_PI = 3.14159265358979323846

	while True:
		axes = adxl345.getAxes(True)
		print ("ADXL345 on address 0x%x:" % (adxl345.address))
		print ("   x = %.3fG" % ( axes['x'] ))
		print ("   y = %.3fG" % ( axes['y'] ))
		print ("   z = %.3fG" % ( axes['z'] ))
		time.sleep(1)

		RawX = axes['x'];
		RawY = axes['y'];
		RawZ = axes['z'];

		x = RawX * (  (2 * EARTH_GRAVITY_MS2) / 512);
		y = RawY * (  (2 * EARTH_GRAVITY_MS2) / 512);
		z = RawZ * (  (2 * EARTH_GRAVITY_MS2) / 512);

		roll = (math.atan2(y, math.sqrt(x*x + z*z))*180.0)/M_PI;
		pitch = (math.atan2(x, math.sqrt(y*y + z*z))*180.0)/M_PI;
		print ("roll:%.3f, pitch:%.3f" % (roll,pitch))
		
###############################################################################################################################



// imu 토픽 연결 // 
https://github.com/SiChiTong/autonomous_bicycle/blob/master/src/sensor_imu_publisher.py#L59
https://github.com/SiChiTong/autonomous_bicycle/blob/master/scripts/imu_to_angles.py
두개를 참고해서 만든다.

// ROS rviz imu 시각화 //
http://wiki.ros.org/rviz_imu_plugin?distro=melodic

// 참고 // 
https://www.robotshop.com/community/robots/show/autonomous-navigation-mecanum-wheel-robot# // 로봇 만들음
https://github.com/ranbo0311/Mecanum_robot?utm_source=rb-community&utm_medium=robots&utm_campaign=autonomous-navigation-mecanum-wheel-robot // 로봇 만든거 깃허브
http://wiki.ros.org/imu_filter_madgwick // imu 연동
https://answers.ros.org/question/246256/how-to-visualize-imu-data-in-rviz/ // imu 설정시 오류가 나는가에 대한 고찰
http://wiki.ros.org/rviz_imu_plugin // ROS rviz imu 패키지 
https://github.com/googlecartographer/cartographer_ros/issues/985 // imu 참고 사이트
https://mechaworld.tistory.com/11 // 참고, 외발 로봇
https://stackoverflow.com/questions/11089967/how-to-obtain-only-linear-acceleration-from-accelerometer-using-gyroscope // 이중적분 하지 마시오
https://m.blog.naver.com/yuninjae1234/220935189584 // 보정




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 테스트 ///
#!/usr/bin/python

import smbus
import time
import math
import numpy
import rospy
from geometry_msgs.msg import Quaternion, Twist
from tf.broadcaster import TransformBroadcaster
from sensor_msgs.msg import Imu

bus = smbus.SMBus(1)

# ADXL345 device address
ADXL345_DEVICE = 0x53

# ADXL345 constants
EARTH_GRAVITY_MS2   = 9.80665
SCALE_MULTIPLIER    = 0.004

DATA_FORMAT         = 0x31
BW_RATE             = 0x2C
POWER_CTL           = 0x2D

BW_RATE_1600HZ      = 0x0F
BW_RATE_800HZ       = 0x0E
BW_RATE_400HZ       = 0x0D
BW_RATE_200HZ       = 0x0C
BW_RATE_100HZ       = 0x0B
BW_RATE_50HZ        = 0x0A
BW_RATE_25HZ        = 0x09

RANGE_2G            = 0x00
RANGE_4G            = 0x01
RANGE_8G            = 0x02
RANGE_16G           = 0x03

MEASURE             = 0x08
AXES_DATA           = 0x32

MY_PI = 3.14159265358979323846

####################################################################################################
class ADXL345:

	address = None

	def __init__(self, address = ADXL345_DEVICE):        
		self.address = address
		self.setBandwidthRate(BW_RATE_100HZ)
		self.setRange(RANGE_2G)
		self.enableMeasurement()

	def enableMeasurement(self):
		bus.write_byte_data(self.address, POWER_CTL, MEASURE)

	def setBandwidthRate(self, rate_flag):
		bus.write_byte_data(self.address, BW_RATE, rate_flag)

	def setRange(self, range_flag):
		value = bus.read_byte_data(self.address, DATA_FORMAT)
		value &= ~0x0F;
		value |= range_flag;  
		value |= 0x08;
		bus.write_byte_data(self.address, DATA_FORMAT, value)





    # returns the current reading from the sensor for each axis
    # parameter gforce:
    #    False (default): result is returned in m/s^2
    #    True           : result is returned in gs 
	def getAxes(self, gforce = False):
		bytes = bus.read_i2c_block_data(self.address, AXES_DATA, 6)

		x = bytes[0] | (bytes[1] << 8)
		if(x & (1 << 16 - 1)):
			x = x - (1<<16)

		y = bytes[2] | (bytes[3] << 8)
		if(y & (1 << 16 - 1)):
			y = y - (1<<16)

		z = bytes[4] | (bytes[5] << 8)
		if(z & (1 << 16 - 1)):
			z = z - (1<<16)

		x = x * SCALE_MULTIPLIER 
		y = y * SCALE_MULTIPLIER
		z = z * SCALE_MULTIPLIER

		if gforce == False:
			x = x * EARTH_GRAVITY_MS2
			y = y * EARTH_GRAVITY_MS2
			z = z * EARTH_GRAVITY_MS2

		x = round(x, 4)
		y = round(y, 4)
		z = round(z, 4)

		return {"x": x, "y": y, "z": z}
####################################################################################################


####################################################################################################
def quaternion_from_euler(ai, aj, ak, axes='sxyz'):
	"""Return quaternion from Euler angles and axis sequence.
	ai, aj, ak : Euler's roll, pitch and yaw angles
	axes : One of 24 axis sequences as string or encoded tuple

	Source: ROS tf transformations
	https://github.com/ros/geometry        
	"""
	# axis sequences for Euler angles
	_NEXT_AXIS = [1, 2, 0, 1]

	# map axes strings to/from tuples of inner axis, parity, repetition, frame
	_AXES2TUPLE = {
	    'sxyz': (0, 0, 0, 0), 'sxyx': (0, 0, 1, 0), 'sxzy': (0, 1, 0, 0),
	    'sxzx': (0, 1, 1, 0), 'syzx': (1, 0, 0, 0), 'syzy': (1, 0, 1, 0),
	    'syxz': (1, 1, 0, 0), 'syxy': (1, 1, 1, 0), 'szxy': (2, 0, 0, 0),
	    'szxz': (2, 0, 1, 0), 'szyx': (2, 1, 0, 0), 'szyz': (2, 1, 1, 0),
	    'rzyx': (0, 0, 0, 1), 'rxyx': (0, 0, 1, 1), 'ryzx': (0, 1, 0, 1),
	    'rxzx': (0, 1, 1, 1), 'rxzy': (1, 0, 0, 1), 'ryzy': (1, 0, 1, 1),
	    'rzxy': (1, 1, 0, 1), 'ryxy': (1, 1, 1, 1), 'ryxz': (2, 0, 0, 1),
	    'rzxz': (2, 0, 1, 1), 'rxyz': (2, 1, 0, 1), 'rzyz': (2, 1, 1, 1)}

	_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())

	try:
	    firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]
	except (AttributeError, KeyError):
	    _ = _TUPLE2AXES[axes]
	    firstaxis, parity, repetition, frame = axes

	i = firstaxis
	j = _NEXT_AXIS[i+parity]
	k = _NEXT_AXIS[i-parity+1]

	if frame:
	    ai, ak = ak, ai
	if parity:
	    aj = -aj

	ai /= 2.0
	aj /= 2.0
	ak /= 2.0
	ci = math.cos(ai)
	si = math.sin(ai)
	cj = math.cos(aj)
	sj = math.sin(aj)
	ck = math.cos(ak)
	sk = math.sin(ak)
	cc = ci*ck
	cs = ci*sk
	sc = si*ck
	ss = si*sk

	quaternion = numpy.empty((4, ), dtype=numpy.float64)
	if repetition:
	    quaternion[i] = cj*(cs + sc)
	    quaternion[j] = sj*(cc + ss)
	    quaternion[k] = sj*(cs - sc)
	    quaternion[3] = cj*(cc - ss)
	else:
	    quaternion[i] = cj*sc - sj*cs
	    quaternion[j] = cj*ss + sj*cc
	    quaternion[k] = cj*cs - sj*sc
	    quaternion[3] = cj*cc + sj*ss
	if parity:
	    quaternion[j] *= -1

	return quaternion
####################################################################################################











####################################################################################################
if __name__ == "__main__":


	###############################
	# 가속도 센서 세팅 #
	adxl345 = ADXL345()
	seq = 0
	###############################


	############################################################################
	# ROS IMU 전달부 세팅 #
	static_transform = rospy.get_param('~static_transform', [0, 0, 0, 0, 0, 0])
	fixed_frame = rospy.get_param('~fixed_frame', "base_footprint")
	frame_name = rospy.get_param('~frame_name', "imu")
	
	rospy.init_node('my_publisher_Imu', anonymous=True)
	pub = rospy.Publisher('/imu', Imu, queue_size=1)
	odomBroadcaster_imu = TransformBroadcaster()
	
	current_time = rospy.get_time()
	last_time = rospy.get_time()

	rate = rospy.Rate(1)

	############################################################################







	############################################################################
	# 무한루프 #
	while True:

		axes = adxl345.getAxes(True)
		#print ("ADXL345 on address 0x%x:" % (adxl345.address))
		print ("   x = %.3fG" % ( axes['x'] ))
		print ("   y = %.3fG" % ( axes['y'] ))
		print ("   z = %.3fG" % ( axes['z'] ))

		RawX = axes['x'];
		RawY = axes['y'];
		RawZ = axes['z'];

		x = RawX * (  (2 * EARTH_GRAVITY_MS2) / 512);
		y = RawY * (  (2 * EARTH_GRAVITY_MS2) / 512);
		z = RawZ * (  (2 * EARTH_GRAVITY_MS2) / 512);

		roll = (math.atan2(y, math.sqrt(x*x + z*z))*180.0)/MY_PI;
		pitch = (math.atan2(x, math.sqrt(y*y + z*z))*180.0)/MY_PI;
		print ("roll:%.3f, pitch:%.3f" % (roll,pitch))
		# 왼손으로 좌표계 만들고, 손가락 끝을 정면으로 봤을때, 반시계 방향이 + 각도 



		# IMU 토픽 결합 시작 #
		current_time = rospy.get_time()

                quaternion = quaternion_from_euler(
						static_transform[3]*MY_PI/180,
						static_transform[4]*MY_PI/180,
						static_transform[5]*MY_PI/180)

		print ("quaternion1:%.3f, quaternion2:%.3f" % (quaternion[0],quaternion[1]))

		odomBroadcaster_imu.sendTransform(
			(static_transform[0], static_transform[1], static_transform[2]),
			(quaternion[0], quaternion[1], quaternion[2], quaternion[3]),
			rospy.Time.now(), frame_name, fixed_frame)

		imu_msg = Imu()

		imu_msg.linear_acceleration.x = 0.0;
		imu_msg.linear_acceleration.y = 0.0;
		imu_msg.linear_acceleration.z = 9.8;

		imu_msg.angular_velocity.x = 0.0
		imu_msg.angular_velocity.y = 0.0
		imu_msg.angular_velocity.z = 0.0

		quaternion2 = quaternion_from_euler(roll*MY_PI/180 , pitch*MY_PI/180 , 0)
		print ("quaternion2 :%.3f, quaternion2 :%.3f" % (quaternion[0],quaternion[1]))

		imu_msg.orientation.x = quaternion2[0]
		imu_msg.orientation.y = quaternion2[1]
		imu_msg.orientation.z = 0.0
		imu_msg.orientation.w = 0.0

		imu_msg.header.stamp = rospy.Time.now()
		imu_msg.header.frame_id = frame_name
		imu_msg.header.seq = seq
		pub.publish(imu_msg)
		seq += 1
		rate.sleep()
	############################################################################
####################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  tracking_frame = "imu",
  TRAJECTORY_BUILDER_2D.use_imu_data = true

# x*M_PI/180 = rad

# 6050으로 가속도 구하기 
# https://www.i2cdevlib.com/forums/topic/25-mpu-6050s-linear-acceleration-is-way-off/

# flat world #
https://github.com/googlecartographer/cartographer_turtlebot/blob/master/cartographer_turtlebot/cartographer_turtlebot/flat_world_imu_node_main.cc



























































//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// imu 활용하여 맵 그리기 //
map_frame = "map", 
tracking_frame = "imu", 
published_frame = "base_footprint",
odom_frame = "odom",
provide_odom_frame = true,
TRAJECTORY_BUILDER_2D.use_imu_data = true 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#!/usr/bin/python3

import smbus
import time
import math
import numpy
import rospy
from geometry_msgs.msg import Quaternion, Twist
from tf.broadcaster import TransformBroadcaster
from sensor_msgs.msg import Imu

bus = smbus.SMBus(1)

# ADXL345 device address
ADXL345_DEVICE = 0x53

# ADXL345 constants
EARTH_GRAVITY_MS2   = 9.80665
SCALE_MULTIPLIER    = 0.004

DATA_FORMAT         = 0x31
BW_RATE             = 0x2C
POWER_CTL           = 0x2D

BW_RATE_1600HZ      = 0x0F
BW_RATE_800HZ       = 0x0E
BW_RATE_400HZ       = 0x0D
BW_RATE_200HZ       = 0x0C
BW_RATE_100HZ       = 0x0B
BW_RATE_50HZ        = 0x0A
BW_RATE_25HZ        = 0x09

RANGE_2G            = 0x00
RANGE_4G            = 0x01
RANGE_8G            = 0x02
RANGE_16G           = 0x03

MEASURE             = 0x08
AXES_DATA           = 0x32

MY_PI = 3.14159265358979323846

####################################################################################################
class ADXL345:

	address = None

	def __init__(self, address = ADXL345_DEVICE):        
		self.address = address
		self.setBandwidthRate(BW_RATE_100HZ)
		self.setRange(RANGE_2G)
		self.enableMeasurement()

	def enableMeasurement(self):
		bus.write_byte_data(self.address, POWER_CTL, MEASURE)

	def setBandwidthRate(self, rate_flag):
		bus.write_byte_data(self.address, BW_RATE, rate_flag)

	def setRange(self, range_flag):
		value = bus.read_byte_data(self.address, DATA_FORMAT)
		value &= ~0x0F;
		value |= range_flag;  
		value |= 0x08;
		bus.write_byte_data(self.address, DATA_FORMAT, value)





    # returns the current reading from the sensor for each axis
    # parameter gforce:
    #    False (default): result is returned in m/s^2
    #    True           : result is returned in gs 
	def getAxes(self, gforce = False):
		bytes = bus.read_i2c_block_data(self.address, AXES_DATA, 6)

		x = bytes[0] | (bytes[1] << 8)
		if(x & (1 << 16 - 1)):
			x = x - (1<<16)

		y = bytes[2] | (bytes[3] << 8)
		if(y & (1 << 16 - 1)):
			y = y - (1<<16)

		z = bytes[4] | (bytes[5] << 8)
		if(z & (1 << 16 - 1)):
			z = z - (1<<16)

		x = x * SCALE_MULTIPLIER 
		y = y * SCALE_MULTIPLIER
		z = z * SCALE_MULTIPLIER

		if gforce == False:
			x = x * EARTH_GRAVITY_MS2
			y = y * EARTH_GRAVITY_MS2
			z = z * EARTH_GRAVITY_MS2

		x = round(x, 4)
		y = round(y, 4)
		z = round(z, 4)

		return {"x": x, "y": y, "z": z}
####################################################################################################


####################################################################################################
def quaternion_from_euler(ai, aj, ak, axes='sxyz'):
	"""Return quaternion from Euler angles and axis sequence.
	ai, aj, ak : Euler's roll, pitch and yaw angles
	axes : One of 24 axis sequences as string or encoded tuple

	Source: ROS tf transformations
	https://github.com/ros/geometry        
	"""
	# axis sequences for Euler angles
	_NEXT_AXIS = [1, 2, 0, 1]

	# map axes strings to/from tuples of inner axis, parity, repetition, frame
	_AXES2TUPLE = {
	    'sxyz': (0, 0, 0, 0), 'sxyx': (0, 0, 1, 0), 'sxzy': (0, 1, 0, 0),
	    'sxzx': (0, 1, 1, 0), 'syzx': (1, 0, 0, 0), 'syzy': (1, 0, 1, 0),
	    'syxz': (1, 1, 0, 0), 'syxy': (1, 1, 1, 0), 'szxy': (2, 0, 0, 0),
	    'szxz': (2, 0, 1, 0), 'szyx': (2, 1, 0, 0), 'szyz': (2, 1, 1, 0),
	    'rzyx': (0, 0, 0, 1), 'rxyx': (0, 0, 1, 1), 'ryzx': (0, 1, 0, 1),
	    'rxzx': (0, 1, 1, 1), 'rxzy': (1, 0, 0, 1), 'ryzy': (1, 0, 1, 1),
	    'rzxy': (1, 1, 0, 1), 'ryxy': (1, 1, 1, 1), 'ryxz': (2, 0, 0, 1),
	    'rzxz': (2, 0, 1, 1), 'rxyz': (2, 1, 0, 1), 'rzyz': (2, 1, 1, 1)}

	_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())

	try:
	    firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]
	except (AttributeError, KeyError):
	    _ = _TUPLE2AXES[axes]
	    firstaxis, parity, repetition, frame = axes

	i = firstaxis
	j = _NEXT_AXIS[i+parity]
	k = _NEXT_AXIS[i-parity+1]

	if frame:
	    ai, ak = ak, ai
	if parity:
	    aj = -aj

	ai /= 2.0
	aj /= 2.0
	ak /= 2.0
	ci = math.cos(ai)
	si = math.sin(ai)
	cj = math.cos(aj)
	sj = math.sin(aj)
	ck = math.cos(ak)
	sk = math.sin(ak)
	cc = ci*ck
	cs = ci*sk
	sc = si*ck
	ss = si*sk

	quaternion = numpy.empty((4, ), dtype=numpy.float64)
	if repetition:
	    quaternion[i] = cj*(cs + sc)
	    quaternion[j] = sj*(cc + ss)
	    quaternion[k] = sj*(cs - sc)
	    quaternion[3] = cj*(cc - ss)
	else:
	    quaternion[i] = cj*sc - sj*cs
	    quaternion[j] = cj*ss + sj*cc
	    quaternion[k] = cj*cs - sj*sc
	    quaternion[3] = cj*cc + sj*ss
	if parity:
	    quaternion[j] *= -1

	return quaternion
####################################################################################################











####################################################################################################
if __name__ == "__main__":


	###############################
	# 가속도 센서 세팅 #
	adxl345 = ADXL345()
	seq = 0
	###############################


	############################################################################
	# ROS IMU 전달부 세팅 #
	static_transform = rospy.get_param('~static_transform', [0, 0, 0, 0, 0, 0])
	fixed_frame = rospy.get_param('~fixed_frame', "base_footprint")
	frame_name = rospy.get_param('~frame_name', "imu")
	
	rospy.init_node('my_publisher_Imu', anonymous=True)
	pub = rospy.Publisher('/imu', Imu, queue_size=1)
	odomBroadcaster_imu = TransformBroadcaster()
	
	current_time = rospy.get_time()
	last_time = rospy.get_time()

	rate = rospy.Rate(1)

	############################################################################







	############################################################################
	# 무한루프 #
	# while true로 하면 control c로 안꺼진다. #
	while not rospy.is_shutdown():

		axes = adxl345.getAxes(True)
		#print ("ADXL345 on address 0x%x:" % (adxl345.address))
		print ("   x = %.3fG" % ( axes['x'] ))
		print ("   y = %.3fG" % ( axes['y'] ))
		print ("   z = %.3fG" % ( axes['z'] ))

		RawX = axes['x'];
		RawY = axes['y'];
		RawZ = axes['z'];

		x = RawX * (  (2 * EARTH_GRAVITY_MS2) / 512);
		y = RawY * (  (2 * EARTH_GRAVITY_MS2) / 512);
		z = RawZ * (  (2 * EARTH_GRAVITY_MS2) / 512);

		roll = (math.atan2(y, math.sqrt(x*x + z*z))*180.0)/MY_PI;
		pitch = (math.atan2(x, math.sqrt(y*y + z*z))*180.0)/MY_PI;
		print ("roll:%.3f, pitch:%.3f" % (roll,pitch))
		# 왼손으로 좌표계 만들고, 몸 안쪽으로 손목을 접고
		# 엄지, 검지, 중지 어떤 손가락을 선택하더라도 손가락 끝을 미간을 향하게 하면
		# 반시계 방향이 + 이다. ( adxl345 기준 )



		# IMU 토픽 결합 시작 #
		current_time = rospy.get_time()

		# 실험을 위해서 X축(roll)을 사용해서 yaw값을 만든다. #
                quaternion = quaternion_from_euler(0, 0, roll*MY_PI/180)

		odomBroadcaster_imu.sendTransform(
			(static_transform[0], static_transform[1], static_transform[2]),
			(quaternion[0], quaternion[1], quaternion[2], quaternion[3]),
			rospy.Time.now(), frame_name, fixed_frame)

		imu_msg = Imu()

		imu_msg.linear_acceleration.x = 0.0;
		imu_msg.linear_acceleration.y = 0.0;
		imu_msg.linear_acceleration.z = 9.8;

		imu_msg.angular_velocity.x = 0.0
		imu_msg.angular_velocity.y = 0.0
		imu_msg.angular_velocity.z = 0.0

		quaternion2 = quaternion_from_euler(0 , 0 , roll*MY_PI/180)
		imu_msg.orientation.x = 0.0
		imu_msg.orientation.y = 0.0
		imu_msg.orientation.z = quaternion2[2]
		imu_msg.orientation.w = 0.0

		imu_msg.header.stamp = rospy.Time.now()
		imu_msg.header.frame_id = frame_name
		imu_msg.header.seq = seq
		pub.publish(imu_msg)
		seq += 1
		rate.sleep()
	############################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

