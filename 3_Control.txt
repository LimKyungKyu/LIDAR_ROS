// 1. waveshare 젯봇에서 분리 시키기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
https://github.com/waveshare/jetbot.git

cd && mkdir temp_jetbot && cd temp_jetbot
git clone https://github.com/waveshare/jetbot.git

cd && mkdir -p my_control_test/src && cd my_control_test/src
catkin_create_pkg my_control std_msgs roscpp rospy tf
cd ~/my_control_test && catkin_make

cd && cd my_control_test/src/my_control/include && vi motor.py
###############################################################################################################################
import atexit
from Adafruit_MotorHAT import Adafruit_MotorHAT
import traitlets
from traitlets.config.configurable import Configurable


class Motor(Configurable):

    value = traitlets.Float()
    
    # config
    alpha = traitlets.Float(default_value=1.0).tag(config=True)
    beta = traitlets.Float(default_value=0.0).tag(config=True)

    def __init__(self, driver, channel, *args, **kwargs):
        super(Motor, self).__init__(*args, **kwargs)  # initializes traitlets

        self._driver = driver
        self._motor = self._driver.getMotor(channel)
        atexit.register(self._release)
        
    @traitlets.observe('value')
    def _observe_value(self, change):
        self._write_value(change['new'])

    def _write_value(self, value):
        """Sets motor value between [-1, 1]"""
        mapped_value = int(255.0 * (self.alpha * value + self.beta))
        speed = min(max(abs(mapped_value), 0), 255)
        self._motor.setSpeed(speed)
        if mapped_value < 0:
            self._motor.run(Adafruit_MotorHAT.FORWARD)
        else:
            self._motor.run(Adafruit_MotorHAT.BACKWARD)

    def _release(self):
        """Stops motor by releasing control"""
        self._motor.run(Adafruit_MotorHAT.RELEASE)

###############################################################################################################################


cd && cd my_control_test/src/my_control/include && vi robot.py
###############################################################################################################################
import time
import traitlets
from traitlets.config.configurable import SingletonConfigurable
from Adafruit_MotorHAT import Adafruit_MotorHAT
from motor import Motor


class Robot(SingletonConfigurable):
    
    left_motor = traitlets.Instance(Motor)
    right_motor = traitlets.Instance(Motor)

    # config
    i2c_bus = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_channel = traitlets.Integer(default_value=1).tag(config=True)
    left_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    right_motor_channel = traitlets.Integer(default_value=2).tag(config=True)
    right_motor_alpha = traitlets.Float(default_value=1.0).tag(config=True)
    
    def __init__(self, *args, **kwargs):
        super(Robot, self).__init__(*args, **kwargs)
        self.motor_driver = Adafruit_MotorHAT(i2c_bus=self.i2c_bus)
        self.left_motor = Motor(self.motor_driver, channel=self.left_motor_channel, alpha=self.left_motor_alpha)
        self.right_motor = Motor(self.motor_driver, channel=self.right_motor_channel, alpha=self.right_motor_alpha)
        
    def set_motors(self, left_speed, right_speed):
        self.left_motor.value = left_speed
        self.right_motor.value = right_speed
        
    def forward(self, speed=1.0, duration=None):
        self.left_motor.value = speed
        self.right_motor.value = speed

    def backward(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = -speed

    def left(self, speed=1.0):
        self.left_motor.value = -speed
        self.right_motor.value = speed

    def right(self, speed=1.0):
        self.left_motor.value = speed
        self.right_motor.value = -speed

    def stop(self):
        self.left_motor.value = 0
        self.right_motor.value = 0

###############################################################################################################################

cd && cd my_control_test/src/my_control/src && vi move.py
###############################################################################################################################
#!/usr/bin/env python3

from robot import Robot
import time # time.sleep(0.5) 을 사용하기 위한 모듈 time을 import한다.

# 방향 조절
# robot.left
# robot.right
# robot.forward
# robot.backwards

robot = Robot()
robot.left(speed=0.3) # 왼쪽 모터 최대 속도의 30%로 지정
robot.left(0.3) # 위와 같은 표현이다.
time.sleep(0.5) # 0.5초 동안 유지한다.
robot.stop()


# 회전 조절
robot.set_motors(0.3, 0.6) # 좌 회전
time.sleep(1.0)
robot.stop()

# 같은 표현
robot.left_motor.value = 0.3
robot.right_motor.value = 0.6
time.sleep(1.0)
robot.left_motor.value = 0.0
robot.right_motor.value = 0.0
###############################################################################################################################

cd && cd my_control_test/src/my_control/src && chmod +x move.py
cd && cd my_control_test/src/my_control && vi CMakeLists.txt
catkin_package(
#  INCLUDE_DIRS include
   LIBRARIES my_control
   CATKIN_DEPENDS rospy std_msgs message_runtime
#  DEPENDS system_lib
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

cd ~/my_control_test && catkin_make
export PYTHONPATH="${PYTHONPATH}:/home/nvidia/my_control_test/src/my_control/include"
echo "source ~/my_control_test/devel/setup.bash" >> ~/.bashrc && source ~/.bashrc
	오류시 sudo apt-get install python3-pip
	python3 -m pip install traitlets
	python3 -m pip install Adafruit_MotorHAT
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////













// 2. 키보드 입력으로 작동시키기 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cd && vi test.py
python3 -m pip install keyboard
###############################################################################################################################
#!/usr/bin/python3

import time
import keyboard
while True:
	try:
		if keyboard.is_pressed('q'):
			print('You Pressed q Key!')
			time.sleep(0.01)
		else: 
			pass 
	except: 
		break
###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 3. 방향키 값 캐치 //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cd && vi test.py
python3 -m pip install keyboard
###############################################################################################################################
#!/usr/bin/python3

import time
import keyboard
while True:
	try:
		if keyboard.is_pressed("up arrow"):
			print('You Pressed Up Key!')
			robot.set_motors(0.3, 0.6)
			time.sleep(1.0)
			robot.stop()
		else: 
			pass 
	except: 
		break
###############################################################################################################################
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





















































// KEYES-345 이용해서 가속도로 각도 구하기 //
// 직접 계산
http://students.iitk.ac.in/roboclub/2017/12/21/Beginners-Guide-to-IMU.html
roll, pitch를 정확하게 계산한 사이트

http://wizmoz.blogspot.com/2013/01/simple-accelerometer-data-conversion-to.html?_sm_au_=iVVrPJjs44Sjbntq
그냥 참고용

// yaw값을 구하지 못하는 이유
http://mythinkg.blogspot.com/2014/03/mpu-6050-rollpitch.html

// 파이썬 코드 (성공)
https://github.com/Seeed-Studio/Grove_Starter_Kit_for_BBG/blob/master/grove_accelerometer_16g/adxl345.py

// 필요 패키지
sudo apt-get install git build-essential python3-dev python-dev
git clone https://github.com/adafruit/Adafruit_Python_ADXL345.git
cd Adafruit_Python_ADXL345
sudo python3 setup.py install
python3 -m pip install adafruit-adxl345
python3 -m pip install smbus

###############################################################################################################################
#!/usr/bin/python3

import smbus
import time
import math

bus = smbus.SMBus(1)

# ADXL345 device address
ADXL345_DEVICE = 0x53

# ADXL345 constants
EARTH_GRAVITY_MS2   = 9.80665
SCALE_MULTIPLIER    = 0.004

DATA_FORMAT         = 0x31
BW_RATE             = 0x2C
POWER_CTL           = 0x2D

BW_RATE_1600HZ      = 0x0F
BW_RATE_800HZ       = 0x0E
BW_RATE_400HZ       = 0x0D
BW_RATE_200HZ       = 0x0C
BW_RATE_100HZ       = 0x0B
BW_RATE_50HZ        = 0x0A
BW_RATE_25HZ        = 0x09

RANGE_2G            = 0x00
RANGE_4G            = 0x01
RANGE_8G            = 0x02
RANGE_16G           = 0x03

MEASURE             = 0x08
AXES_DATA           = 0x32

class ADXL345:

	address = None

	def __init__(self, address = ADXL345_DEVICE):        
		self.address = address
		self.setBandwidthRate(BW_RATE_100HZ)
		self.setRange(RANGE_2G)
		self.enableMeasurement()

	def enableMeasurement(self):
		bus.write_byte_data(self.address, POWER_CTL, MEASURE)

	def setBandwidthRate(self, rate_flag):
		bus.write_byte_data(self.address, BW_RATE, rate_flag)

    # set the measurement range for 10-bit readings
	def setRange(self, range_flag):
		value = bus.read_byte_data(self.address, DATA_FORMAT)

		value &= ~0x0F;
		value |= range_flag;  
		value |= 0x08;

		bus.write_byte_data(self.address, DATA_FORMAT, value)
    
    # returns the current reading from the sensor for each axis
    #
    # parameter gforce:
    #    False (default): result is returned in m/s^2
    #    True           : result is returned in gs
	def getAxes(self, gforce = False):
		bytes = bus.read_i2c_block_data(self.address, AXES_DATA, 6)
		
		x = bytes[0] | (bytes[1] << 8)
		if(x & (1 << 16 - 1)):
			x = x - (1<<16)

		y = bytes[2] | (bytes[3] << 8)
		if(y & (1 << 16 - 1)):
			y = y - (1<<16)

		z = bytes[4] | (bytes[5] << 8)
		if(z & (1 << 16 - 1)):
			z = z - (1<<16)

		x = x * SCALE_MULTIPLIER 
		y = y * SCALE_MULTIPLIER
		z = z * SCALE_MULTIPLIER

		if gforce == False:
			x = x * EARTH_GRAVITY_MS2
			y = y * EARTH_GRAVITY_MS2
			z = z * EARTH_GRAVITY_MS2

		x = round(x, 4)
		y = round(y, 4)
		z = round(z, 4)

		return {"x": x, "y": y, "z": z}

if __name__ == "__main__":
	# if run directly we'll just create an instance of the class and output 
	# the current readings
	adxl345 = ADXL345()
	M_PI = 3.14159265358979323846

	while True:
		axes = adxl345.getAxes(True)
		print ("ADXL345 on address 0x%x:" % (adxl345.address))
		print ("   x = %.3fG" % ( axes['x'] ))
		print ("   y = %.3fG" % ( axes['y'] ))
		print ("   z = %.3fG" % ( axes['z'] ))
		time.sleep(1)

		RawX = axes['x'];
		RawY = axes['y'];
		RawZ = axes['z'];

		x = RawX * (  (2 * EARTH_GRAVITY_MS2) / 512);
		y = RawY * (  (2 * EARTH_GRAVITY_MS2) / 512);
		z = RawZ * (  (2 * EARTH_GRAVITY_MS2) / 512);

		roll = (math.atan2(y, math.sqrt(x*x + z*z))*180.0)/M_PI;
		pitch = (math.atan2(x, math.sqrt(y*y + z*z))*180.0)/M_PI;
		print ("roll:%.3f, pitch:%.3f" % (roll,pitch))
		
###############################################################################################################################
https://pinkwink.kr/1072 따라해보기
https://answers.ros.org/question/246256/how-to-visualize-imu-data-in-rviz/ 살펴보기

// imu 참고 사이트 //
https://github.com/googlecartographer/cartographer_ros/issues/985
https://github.com/googlecartographer/cartographer_ros/tree/master/cartographer_ros

// imu 사용 개인 로봇 만들기 //
https://www.robotshop.com/community/robots/show/autonomous-navigation-mecanum-wheel-robot#
// 깃허브 자료 //
https://github.com/ranbo0311/Mecanum_robot?utm_source=rb-community&utm_medium=robots&utm_campaign=autonomous-navigation-mecanum-wheel-robot

// ROS rviz imu 패키지 //
http://wiki.ros.org/rviz_imu_plugin





// imu 토픽 연결 // 
https://github.com/SiChiTong/autonomous_bicycle/blob/master/src/sensor_imu_publisher.py#L59
https://github.com/SiChiTong/autonomous_bicycle/blob/master/scripts/imu_to_angles.py
두개를 참고해서 만든다.

// ROS rviz imu 시각화 //
http://wiki.ros.org/rviz_imu_plugin?distro=melodic

// 참고 // 
https://www.robotshop.com/community/robots/show/autonomous-navigation-mecanum-wheel-robot# // 로봇 만들음
http://wiki.ros.org/imu_filter_madgwick // imu 연동
https://answers.ros.org/question/246256/how-to-visualize-imu-data-in-rviz/ // imu 설정시 오류가 나는가에 대한 고찰








/// 테스트 ///
#!/usr/bin/python3

import smbus
import time
import math
import rospy
from geometry_msgs.msg import Quaternion, Twist
from tf.broadcaster import TransformBroadcaster
from sensor_msgs.msg import Imu

bus = smbus.SMBus(1)

# ADXL345 device address
ADXL345_DEVICE = 0x53

# ADXL345 constants
EARTH_GRAVITY_MS2   = 9.80665
SCALE_MULTIPLIER    = 0.004

DATA_FORMAT         = 0x31
BW_RATE             = 0x2C
POWER_CTL           = 0x2D

BW_RATE_1600HZ      = 0x0F
BW_RATE_800HZ       = 0x0E
BW_RATE_400HZ       = 0x0D
BW_RATE_200HZ       = 0x0C
BW_RATE_100HZ       = 0x0B
BW_RATE_50HZ        = 0x0A
BW_RATE_25HZ        = 0x09

RANGE_2G            = 0x00
RANGE_4G            = 0x01
RANGE_8G            = 0x02
RANGE_16G           = 0x03

MEASURE             = 0x08
AXES_DATA           = 0x32

class ADXL345:

	address = None

	def __init__(self, address = ADXL345_DEVICE):        
		self.address = address
		self.setBandwidthRate(BW_RATE_100HZ)
		self.setRange(RANGE_2G)
		self.enableMeasurement()

	def enableMeasurement(self):
		bus.write_byte_data(self.address, POWER_CTL, MEASURE)

	def setBandwidthRate(self, rate_flag):
		bus.write_byte_data(self.address, BW_RATE, rate_flag)

    # set the measurement range for 10-bit readings
	def setRange(self, range_flag):
		value = bus.read_byte_data(self.address, DATA_FORMAT)

		value &= ~0x0F;
		value |= range_flag;  
		value |= 0x08;

		bus.write_byte_data(self.address, DATA_FORMAT, value)
    
    # returns the current reading from the sensor for each axis
    #
    # parameter gforce:
    #    False (default): result is returned in m/s^2
    #    True           : result is returned in gs
	def getAxes(self, gforce = False):
		bytes = bus.read_i2c_block_data(self.address, AXES_DATA, 6)
		
		x = bytes[0] | (bytes[1] << 8)
		if(x & (1 << 16 - 1)):
			x = x - (1<<16)

		y = bytes[2] | (bytes[3] << 8)
		if(y & (1 << 16 - 1)):
			y = y - (1<<16)

		z = bytes[4] | (bytes[5] << 8)
		if(z & (1 << 16 - 1)):
			z = z - (1<<16)

		x = x * SCALE_MULTIPLIER 
		y = y * SCALE_MULTIPLIER
		z = z * SCALE_MULTIPLIER

		if gforce == False:
			x = x * EARTH_GRAVITY_MS2
			y = y * EARTH_GRAVITY_MS2
			z = z * EARTH_GRAVITY_MS2

		x = round(x, 4)
		y = round(y, 4)
		z = round(z, 4)

		return {"x": x, "y": y, "z": z}

if __name__ == "__main__":
	# if run directly we'll just create an instance of the class and output 
	# the current readings
	adxl345 = ADXL345()
	M_PI = 3.14159265358979323846
	seq = 0
        
	fixed_frame = rospy.get_param('~fixed_frame', "world")
        frame_name = rospy.get_param('~frame_name', "imu")

	rospy.init_node('my_publisher_Imu', anonymous=True)
	odomBroadcaster_imu = TransformBroadcaster()
	rate = rospy.Rate(1)

	while True:
		axes = adxl345.getAxes(True)
		print ("ADXL345 on address 0x%x:" % (adxl345.address))
		print ("   x = %.3fG" % ( axes['x'] ))
		print ("   y = %.3fG" % ( axes['y'] ))
		print ("   z = %.3fG" % ( axes['z'] ))
		time.sleep(1)

		RawX = axes['x'];
		RawY = axes['y'];
		RawZ = axes['z'];

		x = RawX * (  (2 * EARTH_GRAVITY_MS2) / 512);
		y = RawY * (  (2 * EARTH_GRAVITY_MS2) / 512);
		z = RawZ * (  (2 * EARTH_GRAVITY_MS2) / 512);

		roll = (math.atan2(y, math.sqrt(x*x + z*z))*180.0)/M_PI;
		pitch = (math.atan2(x, math.sqrt(y*y + z*z))*180.0)/M_PI;
		print ("roll:%.3f, pitch:%.3f" % (roll,pitch))
		# 왼손으로 좌표계 만들고
		# 손가락 끝을 정면으로 봤을때
		# 반시계방향이 + 각도 

		pub = rospy.Publisher('/imu', Imu, queue_size=1)

		imu_msg = Imu()
		imu_msg.orientation_covariance[0] = -1
		imu_msg.angular_velocity_covariance[0] = -1
		imu_msg.linear_acceleration_covariance[0] = -1

		imu_msg.linear_acceleration.x = RawX
		imu_msg.linear_acceleration.y = RawY
		imu_msg.linear_acceleration.z = RawZ

		imu_msg.header.stamp = rospy.Time.now()
		imu_msg.header.frame_id = rospy.get_param('~frame_name', "imu")
		imu_msg.header.seq = seq
		pub.publish(imu_msg)
		seq += 1
		rate.sleep()

		

